# 1.3.06. FastAPI Log

> **작성자**: Bern
> **작성일**: 2025-10-26
> **카테고리**: 웹 프레임워크

---

## 목차
1. [로그의 필요성](#1-로그의-필요성)
2. [Python logging 모듈](#2-python-logging-모듈)
3. [FastAPI 로그 설정](#3-fastapi-로그-설정)
4. [로그 레벨과 포맷](#4-로그-레벨과-포맷)
5. [파일 로깅](#5-파일-로깅)
6. [요청/응답 로깅](#6-요청응답-로깅)
7. [실무 로깅 전략](#7-실무-로깅-전략)
8. [실습 코드](#8-실습-코드)

---

## 1. 로그의 필요성

### 1.1. 로그란?

**로그(Log)**는 애플리케이션의 실행 과정과 상태를 기록한 정보입니다.

### 1.2. 로그를 사용하는 이유

| 이유 | 설명 |
|-----|------|
| **디버깅** | 버그 발생 시 원인 파악 |
| **모니터링** | 애플리케이션 상태 추적 |
| **성능 분석** | 느린 API 찾기 |
| **보안** | 비정상 접근 감지 |
| **감사** | 누가 언제 무엇을 했는지 기록 |

### 1.3. print vs logging

```python
# ❌ print 사용 (권장하지 않음)
@app.get("/users/{user_id}")
def get_user(user_id: int):
    print(f"Getting user {user_id}")  # 레벨 구분 없음, 파일 저장 어려움
    return {"id": user_id}

# ✅ logging 사용 (권장)
import logging

logger = logging.getLogger(__name__)

@app.get("/users/{user_id}")
def get_user(user_id: int):
    logger.info(f"Getting user {user_id}")  # 레벨 구분, 파일 저장 가능
    return {"id": user_id}
```

**logging의 장점**:
- 로그 레벨 구분 (DEBUG, INFO, WARNING, ERROR, CRITICAL)
- 파일 저장 가능
- 포맷 지정 (시간, 파일명, 줄 번호 등)
- 여러 출력 대상 (콘솔, 파일, 원격 서버)

---

## 2. Python logging 모듈

### 2.1. 로그 레벨

Python logging은 5가지 레벨을 제공합니다.

| 레벨 | 숫자 | 용도 | 예시 |
|-----|-----|------|------|
| **DEBUG** | 10 | 상세한 디버깅 정보 | 변수 값, 함수 호출 추적 |
| **INFO** | 20 | 일반 정보 | 서버 시작, 요청 처리 |
| **WARNING** | 30 | 경고 메시지 | 더 이상 사용되지 않는 기능 |
| **ERROR** | 40 | 에러 발생 | 예외 처리, 실패한 작업 |
| **CRITICAL** | 50 | 심각한 오류 | 서버 다운, 치명적 오류 |

### 2.2. 기본 사용법

```python
import logging

# 로거 생성
logger = logging.getLogger(__name__)

# 로그 레벨 설정
logger.setLevel(logging.DEBUG)

# 핸들러 생성 (콘솔 출력)
handler = logging.StreamHandler()
handler.setLevel(logging.DEBUG)

# 포맷 설정
formatter = logging.Formatter(
    '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
handler.setFormatter(formatter)

# 핸들러 추가
logger.addHandler(handler)

# 로그 출력
logger.debug("디버그 메시지")
logger.info("정보 메시지")
logger.warning("경고 메시지")
logger.error("에러 메시지")
logger.critical("치명적 오류 메시지")
```

**출력 예시**:
```
2025-10-26 10:30:15,123 - __main__ - DEBUG - 디버그 메시지
2025-10-26 10:30:15,124 - __main__ - INFO - 정보 메시지
2025-10-26 10:30:15,125 - __main__ - WARNING - 경고 메시지
2025-10-26 10:30:15,126 - __main__ - ERROR - 에러 메시지
2025-10-26 10:30:15,127 - __main__ - CRITICAL - 치명적 오류 메시지
```

### 2.3. 로거 구조

```
Logger
  ├── Handler (콘솔)
  │     └── Formatter
  ├── Handler (파일)
  │     └── Formatter
  └── Handler (원격 서버)
        └── Formatter
```

- **Logger**: 로그를 생성
- **Handler**: 로그를 어디에 출력할지 결정 (콘솔, 파일 등)
- **Formatter**: 로그 형식 지정

---

## 3. FastAPI 로그 설정

### 3.1. 기본 로그 설정

```python
# logging_config.py
import logging

def setup_logging():
    """로깅 기본 설정"""
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
```

```python
# main.py
from fastapi import FastAPI
from logging_config import setup_logging
import logging

# 로깅 설정
setup_logging()
logger = logging.getLogger(__name__)

app = FastAPI()

@app.on_event("startup")
def startup_event():
    logger.info("Application starting up...")

@app.on_event("shutdown")
def shutdown_event():
    logger.info("Application shutting down...")

@app.get("/")
def root():
    logger.info("Root endpoint called")
    return {"message": "Hello World"}
```

### 3.2. uvicorn 로그 설정

```python
# main.py
import uvicorn

if __name__ == "__main__":
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        log_level="info",  # 로그 레벨
        access_log=True    # 액세스 로그 출력
    )
```

**uvicorn 로그 레벨**:
- `critical`: 치명적 오류만
- `error`: 에러 이상
- `warning`: 경고 이상
- `info`: 정보 이상 (기본값)
- `debug`: 모든 로그

---

## 4. 로그 레벨과 포맷

### 4.1. 환경별 로그 레벨

```python
import os
import logging

# 환경 변수로 로그 레벨 설정
LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO")

logging.basicConfig(
    level=getattr(logging, LOG_LEVEL.upper()),
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
```

**환경별 설정**:
- **개발**: DEBUG (모든 로그 출력)
- **스테이징**: INFO (정보 이상)
- **운영**: WARNING (경고 이상)

### 4.2. 로그 포맷 커스터마이징

```python
# 상세한 포맷
detailed_format = logging.Formatter(
    '%(asctime)s | %(name)s | %(levelname)-8s | %(filename)s:%(lineno)d | %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)

# 간단한 포맷
simple_format = logging.Formatter(
    '%(levelname)s: %(message)s'
)

# JSON 포맷 (로그 분석 도구에 유용)
import json

class JsonFormatter(logging.Formatter):
    def format(self, record):
        log_data = {
            "timestamp": self.formatTime(record, self.datefmt),
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
            "file": record.filename,
            "line": record.lineno
        }
        return json.dumps(log_data, ensure_ascii=False)
```

**포맷 변수**:
| 변수 | 설명 | 예시 |
|-----|------|------|
| `%(asctime)s` | 시간 | `2025-10-26 10:30:15` |
| `%(name)s` | 로거 이름 | `__main__` |
| `%(levelname)s` | 로그 레벨 | `INFO` |
| `%(message)s` | 메시지 | `User created` |
| `%(filename)s` | 파일명 | `main.py` |
| `%(lineno)d` | 줄 번호 | `42` |
| `%(funcName)s` | 함수명 | `create_user` |

---

## 5. 파일 로깅

### 5.1. 기본 파일 로깅

```python
import logging

# 파일 핸들러 생성
file_handler = logging.FileHandler('app.log', encoding='utf-8')
file_handler.setLevel(logging.INFO)

# 포맷 설정
formatter = logging.Formatter(
    '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
file_handler.setFormatter(formatter)

# 로거에 추가
logger = logging.getLogger(__name__)
logger.addHandler(file_handler)

logger.info("This will be saved to app.log")
```

### 5.2. 로그 로테이션 (크기 기반)

```python
from logging.handlers import RotatingFileHandler

# 10MB마다 새 파일 생성, 최대 5개 보관
handler = RotatingFileHandler(
    'app.log',
    maxBytes=10 * 1024 * 1024,  # 10MB
    backupCount=5,
    encoding='utf-8'
)

# app.log (현재)
# app.log.1 (이전)
# app.log.2 (더 이전)
# ...
# app.log.5 (가장 오래됨)
```

### 5.3. 로그 로테이션 (시간 기반)

```python
from logging.handlers import TimedRotatingFileHandler

# 매일 자정에 새 파일 생성, 30일 보관
handler = TimedRotatingFileHandler(
    'app.log',
    when='midnight',  # 자정마다
    interval=1,       # 1일마다
    backupCount=30,   # 30개 보관
    encoding='utf-8'
)

# 다른 옵션:
# when='S'  : 초마다
# when='M'  : 분마다
# when='H'  : 시간마다
# when='D'  : 일마다
# when='W0' : 월요일마다
```

### 5.4. 콘솔 + 파일 동시 출력

```python
import logging
from logging.handlers import RotatingFileHandler

def setup_logging():
    """콘솔과 파일에 동시 로깅"""
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)

    # 포맷
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )

    # 1. 콘솔 핸들러 (INFO 이상)
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)

    # 2. 파일 핸들러 (DEBUG 이상)
    file_handler = RotatingFileHandler(
        'app.log',
        maxBytes=10*1024*1024,
        backupCount=5,
        encoding='utf-8'
    )
    file_handler.setLevel(logging.DEBUG)
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)

    return logger
```

---

## 6. 요청/응답 로깅

### 6.1. Middleware를 이용한 요청 로깅

```python
from fastapi import FastAPI, Request
import logging
import time

app = FastAPI()
logger = logging.getLogger(__name__)

@app.middleware("http")
async def log_requests(request: Request, call_next):
    """모든 HTTP 요청 로깅"""
    # 요청 시작
    start_time = time.time()

    # 요청 정보 로깅
    logger.info(f"Request: {request.method} {request.url.path}")

    # 요청 처리
    response = await call_next(request)

    # 처리 시간 계산
    process_time = time.time() - start_time

    # 응답 정보 로깅
    logger.info(
        f"Response: {request.method} {request.url.path} "
        f"- Status: {response.status_code} "
        f"- Time: {process_time:.3f}s"
    )

    return response
```

**출력 예시**:
```
2025-10-26 10:30:15 - INFO - Request: GET /users/1
2025-10-26 10:30:15 - INFO - Response: GET /users/1 - Status: 200 - Time: 0.025s
```

### 6.2. 상세한 요청 로깅

```python
@app.middleware("http")
async def detailed_logging(request: Request, call_next):
    """상세한 요청/응답 로깅"""
    # 요청 정보
    logger.info(f"{'='*50}")
    logger.info(f"Method: {request.method}")
    logger.info(f"URL: {request.url}")
    logger.info(f"Headers: {dict(request.headers)}")
    logger.info(f"Client: {request.client.host}")

    # Body 로깅 (주의: await은 한 번만 가능)
    if request.method in ["POST", "PUT", "PATCH"]:
        body = await request.body()
        logger.info(f"Body: {body.decode('utf-8')[:500]}")  # 최대 500자

    # 요청 처리
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time

    # 응답 정보
    logger.info(f"Status Code: {response.status_code}")
    logger.info(f"Process Time: {process_time:.3f}s")
    logger.info(f"{'='*50}")

    return response
```

### 6.3. 에러 로깅

```python
from fastapi import FastAPI, HTTPException, Request
from fastapi.responses import JSONResponse
import logging

app = FastAPI()
logger = logging.getLogger(__name__)

@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    """HTTP 예외 로깅"""
    logger.error(
        f"HTTPException: {exc.status_code} - {exc.detail} "
        f"- Path: {request.url.path}"
    )
    return JSONResponse(
        status_code=exc.status_code,
        content={"detail": exc.detail}
    )

@app.exception_handler(Exception)
async def general_exception_handler(request: Request, exc: Exception):
    """일반 예외 로깅"""
    logger.exception(
        f"Unhandled exception: {str(exc)} - Path: {request.url.path}"
    )
    return JSONResponse(
        status_code=500,
        content={"detail": "Internal server error"}
    )
```

---

## 7. 실무 로깅 전략

### 7.1. 환경별 로그 설정

```python
# config.py
import os
from enum import Enum

class Environment(str, Enum):
    DEVELOPMENT = "development"
    STAGING = "staging"
    PRODUCTION = "production"

ENVIRONMENT = os.getenv("ENVIRONMENT", Environment.DEVELOPMENT)

LOG_CONFIG = {
    Environment.DEVELOPMENT: {
        "level": "DEBUG",
        "console": True,
        "file": False
    },
    Environment.STAGING: {
        "level": "INFO",
        "console": True,
        "file": True
    },
    Environment.PRODUCTION: {
        "level": "WARNING",
        "console": False,
        "file": True
    }
}

def get_log_config():
    return LOG_CONFIG[ENVIRONMENT]
```

### 7.2. 구조화된 로깅

```python
import logging
import json
from datetime import datetime

class StructuredLogger:
    """구조화된 로그 출력"""

    def __init__(self, name: str):
        self.logger = logging.getLogger(name)

    def log(self, level: str, message: str, **kwargs):
        """구조화된 로그"""
        log_data = {
            "timestamp": datetime.now().isoformat(),
            "level": level.upper(),
            "message": message,
            **kwargs
        }

        log_message = json.dumps(log_data, ensure_ascii=False)

        if level == "debug":
            self.logger.debug(log_message)
        elif level == "info":
            self.logger.info(log_message)
        elif level == "warning":
            self.logger.warning(log_message)
        elif level == "error":
            self.logger.error(log_message)

# 사용
logger = StructuredLogger(__name__)

logger.log(
    "info",
    "User created",
    user_id=123,
    email="user@example.com",
    ip_address="192.168.1.1"
)
```

**출력**:
```json
{"timestamp": "2025-10-26T10:30:15.123", "level": "INFO", "message": "User created", "user_id": 123, "email": "user@example.com", "ip_address": "192.168.1.1"}
```

### 7.3. 보안 고려사항

```python
import logging
import re

class SensitiveDataFilter(logging.Filter):
    """민감한 정보 필터링"""

    def __init__(self):
        super().__init__()
        # 민감한 패턴 정의
        self.patterns = [
            (re.compile(r'\b\d{4}-\d{4}-\d{4}-\d{4}\b'), '****-****-****-****'),  # 카드번호
            (re.compile(r'\b\d{6}-\d{7}\b'), '******-*******'),  # 주민번호
            (re.compile(r'password["\']?\s*:\s*["\']([^"\']+)["\']', re.I), 'password: ****'),  # 비밀번호
        ]

    def filter(self, record):
        """로그 메시지에서 민감한 정보 마스킹"""
        message = record.getMessage()
        for pattern, replacement in self.patterns:
            message = pattern.sub(replacement, message)
        record.msg = message
        record.args = ()
        return True

# 사용
logger = logging.getLogger(__name__)
logger.addFilter(SensitiveDataFilter())

# "password: secret123" → "password: ****"
logger.info("User login: password: secret123")
```

---

## 8. 실습 코드

### 8.1. 완전한 로깅 시스템

```python
# logging_config.py
import logging
from logging.handlers import RotatingFileHandler
import os

def setup_logging(log_level: str = "INFO", log_to_file: bool = True):
    """
    로깅 시스템 설정

    Args:
        log_level: 로그 레벨 (DEBUG, INFO, WARNING, ERROR, CRITICAL)
        log_to_file: 파일 로깅 여부
    """
    # 로거 생성
    logger = logging.getLogger()
    logger.setLevel(getattr(logging, log_level.upper()))

    # 기존 핸들러 제거 (중복 방지)
    logger.handlers.clear()

    # 포맷 정의
    formatter = logging.Formatter(
        '%(asctime)s | %(name)-20s | %(levelname)-8s | %(filename)s:%(lineno)d | %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )

    # 1. 콘솔 핸들러
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.DEBUG)
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)

    # 2. 파일 핸들러 (선택적)
    if log_to_file:
        # logs 디렉토리 생성
        os.makedirs('logs', exist_ok=True)

        # 일반 로그 파일 (INFO 이상)
        info_handler = RotatingFileHandler(
            'logs/app.log',
            maxBytes=10 * 1024 * 1024,  # 10MB
            backupCount=5,
            encoding='utf-8'
        )
        info_handler.setLevel(logging.INFO)
        info_handler.setFormatter(formatter)
        logger.addHandler(info_handler)

        # 에러 로그 파일 (ERROR 이상)
        error_handler = RotatingFileHandler(
            'logs/error.log',
            maxBytes=10 * 1024 * 1024,
            backupCount=5,
            encoding='utf-8'
        )
        error_handler.setLevel(logging.ERROR)
        error_handler.setFormatter(formatter)
        logger.addHandler(error_handler)

    return logger
```

```python
# middleware.py
from fastapi import Request
import logging
import time
import json

logger = logging.getLogger(__name__)

async def log_middleware(request: Request, call_next):
    """요청/응답 로깅 미들웨어"""

    # 요청 ID 생성 (추적용)
    request_id = str(time.time())

    # 요청 시작
    start_time = time.time()

    # 요청 정보 로깅
    logger.info(
        f"[{request_id}] Request started: "
        f"{request.method} {request.url.path} "
        f"from {request.client.host}"
    )

    # Body 로깅 (POST/PUT/PATCH)
    if request.method in ["POST", "PUT", "PATCH"]:
        try:
            body = await request.body()
            body_str = body.decode('utf-8')
            # JSON인 경우 파싱
            try:
                body_json = json.loads(body_str)
                logger.debug(f"[{request_id}] Request body: {body_json}")
            except:
                logger.debug(f"[{request_id}] Request body: {body_str[:200]}")
        except Exception as e:
            logger.warning(f"[{request_id}] Failed to read request body: {e}")

    # 요청 처리
    try:
        response = await call_next(request)
    except Exception as e:
        process_time = time.time() - start_time
        logger.error(
            f"[{request_id}] Request failed: "
            f"{request.method} {request.url.path} "
            f"- Error: {str(e)} "
            f"- Time: {process_time:.3f}s"
        )
        raise

    # 처리 시간 계산
    process_time = time.time() - start_time

    # 응답 정보 로깅
    log_level = logging.INFO if response.status_code < 400 else logging.WARNING
    logger.log(
        log_level,
        f"[{request_id}] Request completed: "
        f"{request.method} {request.url.path} "
        f"- Status: {response.status_code} "
        f"- Time: {process_time:.3f}s"
    )

    return response
```

```python
# main.py
from fastapi import FastAPI, HTTPException, Request
from fastapi.responses import JSONResponse
from pydantic import BaseModel
import logging
from logging_config import setup_logging
from middleware import log_middleware

# 로깅 설정
setup_logging(log_level="DEBUG", log_to_file=True)
logger = logging.getLogger(__name__)

# FastAPI 앱
app = FastAPI(title="Logging Example API")

# 미들웨어 추가
app.middleware("http")(log_middleware)

# 모델
class User(BaseModel):
    name: str
    email: str

# 예외 핸들러
@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    """HTTP 예외 로깅"""
    logger.error(
        f"HTTPException: {exc.status_code} - {exc.detail} "
        f"- Path: {request.url.path}"
    )
    return JSONResponse(
        status_code=exc.status_code,
        content={"detail": exc.detail}
    )

@app.exception_handler(Exception)
async def general_exception_handler(request: Request, exc: Exception):
    """일반 예외 로깅"""
    logger.exception(f"Unhandled exception - Path: {request.url.path}")
    return JSONResponse(
        status_code=500,
        content={"detail": "Internal server error"}
    )

# 라이프사이클 이벤트
@app.on_event("startup")
async def startup():
    logger.info("=" * 50)
    logger.info("Application starting up...")
    logger.info("=" * 50)

@app.on_event("shutdown")
async def shutdown():
    logger.info("=" * 50)
    logger.info("Application shutting down...")
    logger.info("=" * 50)

# API 엔드포인트
@app.get("/")
def root():
    """루트 엔드포인트"""
    logger.debug("Root endpoint called - This is a DEBUG message")
    logger.info("Root endpoint called - This is an INFO message")
    return {"message": "Logging Example API"}

@app.post("/users")
def create_user(user: User):
    """사용자 생성"""
    logger.info(f"Creating user: {user.name}")
    logger.debug(f"User details: name={user.name}, email={user.email}")
    return {"message": "User created", "user": user}

@app.get("/error")
def trigger_error():
    """에러 발생 테스트"""
    logger.warning("Error endpoint called")
    raise HTTPException(status_code=400, detail="This is a test error")

@app.get("/exception")
def trigger_exception():
    """예외 발생 테스트"""
    logger.warning("Exception endpoint called")
    raise ValueError("This is an unhandled exception")

# 실행
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="info"
    )
```

### 8.2. 테스트 스크립트

```python
# test_logging.py
import requests
import time

BASE_URL = "http://localhost:8000"

def test_logging():
    """로깅 테스트"""

    print("=== 로깅 테스트 시작 ===\n")

    # 1. GET 요청
    print("1. GET /")
    requests.get(f"{BASE_URL}/")
    time.sleep(1)

    # 2. POST 요청
    print("\n2. POST /users")
    requests.post(f"{BASE_URL}/users", json={
        "name": "홍길동",
        "email": "hong@test.com"
    })
    time.sleep(1)

    # 3. 에러 발생
    print("\n3. GET /error (400 에러)")
    requests.get(f"{BASE_URL}/error")
    time.sleep(1)

    # 4. 예외 발생
    print("\n4. GET /exception (500 에러)")
    requests.get(f"{BASE_URL}/exception")

    print("\n=== 로그 파일 확인 ===")
    print("logs/app.log - 모든 로그")
    print("logs/error.log - 에러 로그만")

if __name__ == "__main__":
    test_logging()
```

### 8.3. 실행 방법

```bash
# 1. 서버 실행
python main.py

# 2. 테스트 실행 (다른 터미널)
python test_logging.py

# 3. 로그 파일 확인
cat logs/app.log
cat logs/error.log
```

### 8.4. 예상 로그 출력

**콘솔 출력**:
```
2025-10-26 10:30:15 | __main__             | INFO     | main.py:42 | ==================================================
2025-10-26 10:30:15 | __main__             | INFO     | main.py:43 | Application starting up...
2025-10-26 10:30:15 | __main__             | INFO     | main.py:44 | ==================================================
2025-10-26 10:30:20 | middleware           | INFO     | middleware.py:15 | [1698298220.123] Request started: GET / from 127.0.0.1
2025-10-26 10:30:20 | __main__             | DEBUG    | main.py:55 | Root endpoint called - This is a DEBUG message
2025-10-26 10:30:20 | __main__             | INFO     | main.py:56 | Root endpoint called - This is an INFO message
2025-10-26 10:30:20 | middleware           | INFO     | middleware.py:45 | [1698298220.123] Request completed: GET / - Status: 200 - Time: 0.003s
```

**logs/app.log**:
```
2025-10-26 10:30:15 | __main__             | INFO     | main.py:43 | Application starting up...
2025-10-26 10:30:20 | middleware           | INFO     | middleware.py:15 | [1698298220.123] Request started: GET / from 127.0.0.1
2025-10-26 10:30:20 | __main__             | INFO     | main.py:56 | Root endpoint called - This is an INFO message
2025-10-26 10:30:20 | middleware           | INFO     | middleware.py:45 | [1698298220.123] Request completed: GET / - Status: 200 - Time: 0.003s
2025-10-26 10:30:25 | __main__             | INFO     | main.py:61 | Creating user: 홍길동
2025-10-26 10:30:30 | __main__             | ERROR    | main.py:25 | HTTPException: 400 - This is a test error - Path: /error
```

**logs/error.log** (에러만):
```
2025-10-26 10:30:30 | __main__             | ERROR    | main.py:25 | HTTPException: 400 - This is a test error - Path: /error
2025-10-26 10:30:35 | __main__             | ERROR    | main.py:36 | Unhandled exception - Path: /exception
Traceback (most recent call last):
  ...
ValueError: This is an unhandled exception
```

---

## 마무리

축하합니다! FastAPI 로그 설정을 완료했습니다.

### 학습한 내용 정리

1. **로그의 필요성**: 디버깅, 모니터링, 성능 분석
2. **Python logging 모듈**: 로그 레벨, Logger, Handler, Formatter
3. **FastAPI 로그 설정**: basicConfig, uvicorn 설정
4. **로그 레벨과 포맷**: 환경별 설정, 커스텀 포맷
5. **파일 로깅**: RotatingFileHandler, TimedRotatingFileHandler
6. **요청/응답 로깅**: Middleware를 이용한 자동 로깅
7. **실무 전략**: 환경별 설정, 구조화된 로깅, 보안 고려

### 실무 적용 팁

| 팁 | 설명 |
|-----|------|
| **환경별 설정** | 개발(DEBUG), 운영(WARNING) |
| **파일 로테이션** | 로그 파일이 너무 커지지 않도록 |
| **민감 정보 제거** | 비밀번호, 카드번호 등 마스킹 |
| **구조화된 로그** | JSON 형식으로 로그 분석 도구 활용 |
| **요청 추적** | request_id로 전체 흐름 추적 |

---

**참고 자료**:
- Python logging 문서: https://docs.python.org/ko/3/library/logging.html
- FastAPI 로깅: https://fastapi.tiangolo.com/tutorial/middleware/
- Uvicorn 로깅: https://www.uvicorn.org/settings/#logging
- 12 Factor App - Logs: https://12factor.net/logs
