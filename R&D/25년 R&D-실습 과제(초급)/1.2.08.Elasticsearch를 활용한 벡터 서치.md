# 1.2.08. Elasticsearch를 활용한 벡터 서치

> **작성자**: Bern
> **작성일**: 2025-10-25
> **카테고리**: 데이터 전처리 / 벡터 검색

---

## 목차
1. [벡터 서치 개요](#1-벡터-서치-개요)
2. [Elasticsearch 벡터 저장 준비](#2-elasticsearch-벡터-저장-준비)
3. [임베딩 데이터 저장](#3-임베딩-데이터-저장)
4. [벡터 검색 수행](#4-벡터-검색-수행)
5. [하이브리드 검색 (키워드 + 벡터)](#5-하이브리드-검색-키워드--벡터)
6. [실전 예시: RAG 시스템 구축](#6-실전-예시-rag-시스템-구축)
7. [성능 최적화](#7-성능-최적화)
8. [다음 단계](#8-다음-단계)

---

## 1. 벡터 서치 개요

### 1.1. 벡터 서치란?

**벡터 서치(Vector Search)**는 텍스트를 벡터(숫자 배열)로 변환하여 의미적 유사도를 기반으로 검색하는 방법입니다.

```
기존 키워드 검색:
질문: "스마트팜 센서"
→ "스마트팜", "센서" 키워드가 포함된 문서 검색

벡터 검색:
질문: "스마트팜 센서" → 벡터: [0.2, 0.8, -0.3, ...]
→ 유사한 벡터를 가진 문서 검색 (의미가 비슷한 문서)
  예: "IoT 농업 장치", "온도 측정 시스템" 등도 검색됨
```

### 1.2. Elasticsearch에서의 벡터 서치

Elasticsearch 8.0+에서는 `dense_vector` 타입을 지원하여 벡터 검색이 가능합니다.

**주요 기능**:
- **KNN (K-Nearest Neighbors)**: 가장 유사한 K개의 문서 검색
- **코사인 유사도**: 벡터 간 유사도 측정
- **하이브리드 검색**: 키워드 + 벡터 검색 결합

### 1.3. RAG 시스템에서의 활용

```
사용자 질문
    ↓
[임베딩 모델]
    ↓
질문 벡터
    ↓
[Elasticsearch 벡터 검색]
    ↓
관련 문서 검색
    ↓
[LLM에 전달]
    ↓
답변 생성
```

---

## 2. Elasticsearch 벡터 저장 준비

### 2.1. 인덱스 매핑 생성

벡터를 저장하려면 먼저 `dense_vector` 타입의 매핑을 정의해야 합니다.

```python
from elasticsearch import Elasticsearch

# Elasticsearch 연결
es = Elasticsearch(['http://localhost:9200'])

# 인덱스 이름
index_name = 'smart_farm_documents'

# 매핑 정의
mapping = {
    "mappings": {
        "properties": {
            # 문서 ID
            "doc_id": {
                "type": "keyword"
            },
            # 원본 텍스트
            "text": {
                "type": "text",
                "analyzer": "standard"
            },
            # 임베딩 벡터
            "embedding": {
                "type": "dense_vector",
                "dims": 768,  # 벡터 차원 (모델에 따라 다름)
                "index": True,  # 인덱싱 활성화
                "similarity": "cosine"  # 유사도 측정 방법
            },
            # 메타데이터
            "metadata": {
                "properties": {
                    "source": {"type": "keyword"},
                    "category": {"type": "keyword"},
                    "created_at": {"type": "date"}
                }
            }
        }
    }
}

# 인덱스 생성
if es.indices.exists(index=index_name):
    es.indices.delete(index=index_name)
    print(f"기존 인덱스 '{index_name}' 삭제")

es.indices.create(index=index_name, body=mapping)
print(f"인덱스 '{index_name}' 생성 완료")
```

**중요 파라미터**:
- `dims`: 벡터의 차원 수 (임베딩 모델에 따라 다름)
  - `jhgan/ko-sroberta-multitask`: 768
  - `sentence-transformers/all-MiniLM-L6-v2`: 384
  - OpenAI `text-embedding-ada-002`: 1536
- `similarity`: 유사도 측정 방법
  - `cosine`: 코사인 유사도 (일반적)
  - `dot_product`: 내적
  - `l2_norm`: 유클리드 거리

### 2.2. 인덱스 확인

```python
# 인덱스 매핑 확인
mapping_info = es.indices.get_mapping(index=index_name)
print("인덱스 매핑:")
import json
print(json.dumps(mapping_info, indent=2, ensure_ascii=False))
```

---

## 3. 임베딩 데이터 저장

### 3.1. 텍스트 임베딩 생성

```python
from sentence_transformers import SentenceTransformer

# 임베딩 모델 로드
model = SentenceTransformer('jhgan/ko-sroberta-multitask')

# 문서 데이터
documents = [
    {
        "doc_id": "doc_001",
        "text": "스마트팜은 ICT 기술을 활용하여 농작물 생육 환경을 자동으로 제어합니다.",
        "metadata": {
            "source": "smartfarm_guide.pdf",
            "category": "기술 개요",
            "created_at": "2024-10-25"
        }
    },
    {
        "doc_id": "doc_002",
        "text": "센서를 통해 온도, 습도, CO2 농도를 실시간으로 측정합니다.",
        "metadata": {
            "source": "smartfarm_guide.pdf",
            "category": "센서 기술",
            "created_at": "2024-10-25"
        }
    },
    {
        "doc_id": "doc_003",
        "text": "AI 기술은 병충해를 조기에 감지하고 예측할 수 있습니다.",
        "metadata": {
            "source": "smartfarm_guide.pdf",
            "category": "AI 기술",
            "created_at": "2024-10-25"
        }
    },
    {
        "doc_id": "doc_004",
        "text": "자동 관수 시스템은 토양 수분을 분석하여 최적의 물 공급량을 결정합니다.",
        "metadata": {
            "source": "smartfarm_guide.pdf",
            "category": "제어 시스템",
            "created_at": "2024-10-25"
        }
    },
    {
        "doc_id": "doc_005",
        "text": "빅데이터 분석을 통해 농작물의 최적 생육 환경을 예측합니다.",
        "metadata": {
            "source": "smartfarm_guide.pdf",
            "category": "데이터 분석",
            "created_at": "2024-10-25"
        }
    }
]

# 텍스트 임베딩 생성
texts = [doc['text'] for doc in documents]
embeddings = model.encode(texts)

print(f"임베딩 생성 완료: {len(embeddings)}개")
print(f"임베딩 차원: {embeddings[0].shape}")
print(f"첫 번째 임베딩 벡터 (일부): {embeddings[0][:5]}...")
```

**실행 결과**:
```
임베딩 생성 완료: 5개
임베딩 차원: (768,)
첫 번째 임베딩 벡터 (일부): [ 0.234 -0.567  0.891 -0.123  0.456]...
```

### 3.2. Elasticsearch에 저장 (단일 문서)

```python
# 단일 문서 저장
doc_with_embedding = {
    "doc_id": documents[0]['doc_id'],
    "text": documents[0]['text'],
    "embedding": embeddings[0].tolist(),  # NumPy 배열 → 리스트
    "metadata": documents[0]['metadata']
}

response = es.index(
    index=index_name,
    id=documents[0]['doc_id'],
    document=doc_with_embedding
)

print(f"문서 저장 완료: {response['result']}")
```

### 3.3. 벌크(Bulk) 저장 (여러 문서)

```python
from elasticsearch.helpers import bulk

# 벌크 저장용 데이터 준비
def generate_docs():
    """Elasticsearch 벌크 저장용 제너레이터"""
    for i, doc in enumerate(documents):
        yield {
            "_index": index_name,
            "_id": doc['doc_id'],
            "_source": {
                "doc_id": doc['doc_id'],
                "text": doc['text'],
                "embedding": embeddings[i].tolist(),
                "metadata": doc['metadata']
            }
        }

# 벌크 저장 실행
success, failed = bulk(es, generate_docs())
print(f"저장 성공: {success}개, 실패: {len(failed)}개")

# 인덱스 새로고침 (검색 가능하도록)
es.indices.refresh(index=index_name)
print("인덱스 새로고침 완료")
```

**실행 결과**:
```
저장 성공: 5개, 실패: 0개
인덱스 새로고침 완료
```

### 3.4. 저장된 데이터 확인

```python
# 전체 문서 수 확인
count = es.count(index=index_name)
print(f"총 문서 수: {count['count']}")

# 샘플 문서 조회
sample_doc = es.get(index=index_name, id='doc_001')
print("\n샘플 문서:")
print(f"  ID: {sample_doc['_id']}")
print(f"  텍스트: {sample_doc['_source']['text']}")
print(f"  임베딩 차원: {len(sample_doc['_source']['embedding'])}")
print(f"  메타데이터: {sample_doc['_source']['metadata']}")
```

---

## 4. 벡터 검색 수행

### 4.1. KNN 검색 기본

```python
def vector_search(query_text, k=3):
    """
    벡터 유사도 기반 검색

    Args:
        query_text (str): 검색 질문
        k (int): 반환할 문서 수

    Returns:
        list: 검색 결과
    """
    # 1. 질문 임베딩 생성
    query_embedding = model.encode([query_text])[0]

    # 2. KNN 검색 쿼리
    knn_query = {
        "knn": {
            "field": "embedding",  # 벡터 필드명
            "query_vector": query_embedding.tolist(),  # 질문 벡터
            "k": k,  # 상위 K개 결과
            "num_candidates": 100  # 후보 문서 수 (k보다 크게)
        },
        "_source": ["doc_id", "text", "metadata"]  # 반환할 필드
    }

    # 3. 검색 실행
    response = es.search(index=index_name, body=knn_query)

    # 4. 결과 파싱
    results = []
    for hit in response['hits']['hits']:
        results.append({
            'doc_id': hit['_source']['doc_id'],
            'text': hit['_source']['text'],
            'score': hit['_score'],  # 유사도 점수
            'metadata': hit['_source']['metadata']
        })

    return results


# 검색 예시
query = "온도와 습도를 측정하는 센서"
results = vector_search(query, k=3)

print(f"질문: {query}\n")
print(f"검색 결과 ({len(results)}개):\n")

for i, result in enumerate(results):
    print(f"[{i+1}] (점수: {result['score']:.4f})")
    print(f"    문서 ID: {result['doc_id']}")
    print(f"    텍스트: {result['text']}")
    print(f"    카테고리: {result['metadata']['category']}")
    print("-" * 60)
```

**실행 결과**:
```
질문: 온도와 습도를 측정하는 센서

검색 결과 (3개):

[1] (점수: 0.8924)
    문서 ID: doc_002
    텍스트: 센서를 통해 온도, 습도, CO2 농도를 실시간으로 측정합니다.
    카테고리: 센서 기술
------------------------------------------------------------
[2] (점수: 0.7231)
    문서 ID: doc_001
    텍스트: 스마트팜은 ICT 기술을 활용하여 농작물 생육 환경을 자동으로 제어합니다.
    카테고리: 기술 개요
------------------------------------------------------------
[3] (점수: 0.6845)
    문서 ID: doc_004
    텍스트: 자동 관수 시스템은 토양 수분을 분석하여 최적의 물 공급량을 결정합니다.
    카테고리: 제어 시스템
------------------------------------------------------------
```

### 4.2. 필터 조건 추가

```python
def vector_search_with_filter(query_text, category=None, k=3):
    """
    필터 조건을 포함한 벡터 검색

    Args:
        query_text (str): 검색 질문
        category (str): 카테고리 필터
        k (int): 반환할 문서 수
    """
    query_embedding = model.encode([query_text])[0]

    # 쿼리 구성
    search_query = {
        "knn": {
            "field": "embedding",
            "query_vector": query_embedding.tolist(),
            "k": k,
            "num_candidates": 100
        }
    }

    # 필터 추가
    if category:
        search_query["knn"]["filter"] = {
            "term": {
                "metadata.category.keyword": category
            }
        }

    search_query["_source"] = ["doc_id", "text", "metadata"]

    response = es.search(index=index_name, body=search_query)

    results = []
    for hit in response['hits']['hits']:
        results.append({
            'doc_id': hit['_source']['doc_id'],
            'text': hit['_source']['text'],
            'score': hit['_score'],
            'metadata': hit['_source']['metadata']
        })

    return results


# 카테고리 필터 검색
query = "환경 측정"
category = "센서 기술"
results = vector_search_with_filter(query, category=category, k=2)

print(f"질문: {query}")
print(f"필터: category = {category}\n")

for i, result in enumerate(results):
    print(f"[{i+1}] {result['text']}")
```

---

## 5. 하이브리드 검색 (키워드 + 벡터)

### 5.1. 하이브리드 검색의 필요성

벡터 검색과 키워드 검색을 결합하면 더 정확한 결과를 얻을 수 있습니다.

```
벡터 검색: 의미적 유사도 (동의어, 관련 개념 검색)
키워드 검색: 정확한 용어 매칭 (특정 키워드 포함 문서)

→ 하이브리드: 두 방법의 장점을 결합
```

### 5.2. 하이브리드 검색 구현

```python
def hybrid_search(query_text, k=3, keyword_weight=0.3, vector_weight=0.7):
    """
    키워드 + 벡터 하이브리드 검색

    Args:
        query_text (str): 검색 질문
        k (int): 반환할 문서 수
        keyword_weight (float): 키워드 검색 가중치
        vector_weight (float): 벡터 검색 가중치
    """
    query_embedding = model.encode([query_text])[0]

    # 하이브리드 쿼리
    hybrid_query = {
        "query": {
            "bool": {
                "should": [
                    # 1. 키워드 검색 (BM25)
                    {
                        "match": {
                            "text": {
                                "query": query_text,
                                "boost": keyword_weight  # 가중치
                            }
                        }
                    }
                ]
            }
        },
        # 2. 벡터 검색 (KNN)
        "knn": {
            "field": "embedding",
            "query_vector": query_embedding.tolist(),
            "k": k,
            "num_candidates": 100,
            "boost": vector_weight  # 가중치
        },
        "_source": ["doc_id", "text", "metadata"],
        "size": k
    }

    response = es.search(index=index_name, body=hybrid_query)

    results = []
    for hit in response['hits']['hits']:
        results.append({
            'doc_id': hit['_source']['doc_id'],
            'text': hit['_source']['text'],
            'score': hit['_score'],
            'metadata': hit['_source']['metadata']
        })

    return results


# 하이브리드 검색 예시
query = "AI를 활용한 병충해 예측"
results = hybrid_search(query, k=3, keyword_weight=0.3, vector_weight=0.7)

print(f"질문: {query}\n")
print("하이브리드 검색 결과:\n")

for i, result in enumerate(results):
    print(f"[{i+1}] (점수: {result['score']:.4f})")
    print(f"    {result['text']}")
    print("-" * 60)
```

**실행 결과**:
```
질문: AI를 활용한 병충해 예측

하이브리드 검색 결과:

[1] (점수: 1.2456)
    AI 기술은 병충해를 조기에 감지하고 예측할 수 있습니다.
------------------------------------------------------------
[2] (점수: 0.8734)
    빅데이터 분석을 통해 농작물의 최적 생육 환경을 예측합니다.
------------------------------------------------------------
[3] (점수: 0.6521)
    스마트팜은 ICT 기술을 활용하여 농작물 생육 환경을 자동으로 제어합니다.
------------------------------------------------------------
```

---

## 6. 실전 예시: RAG 시스템 구축

### 6.1. 전체 RAG 파이프라인

```python
class SmartFarmRAG:
    """스마트팜 RAG 시스템"""

    def __init__(self, es_client, index_name, embedding_model):
        """
        Args:
            es_client: Elasticsearch 클라이언트
            index_name: 인덱스 이름
            embedding_model: 임베딩 모델
        """
        self.es = es_client
        self.index_name = index_name
        self.model = embedding_model

    def add_documents(self, documents):
        """
        문서 추가 (임베딩 + 저장)

        Args:
            documents: 문서 리스트
                [{'doc_id': str, 'text': str, 'metadata': dict}, ...]
        """
        # 임베딩 생성
        texts = [doc['text'] for doc in documents]
        embeddings = self.model.encode(texts)

        # 벌크 저장
        def generate_docs():
            for i, doc in enumerate(documents):
                yield {
                    "_index": self.index_name,
                    "_id": doc['doc_id'],
                    "_source": {
                        "doc_id": doc['doc_id'],
                        "text": doc['text'],
                        "embedding": embeddings[i].tolist(),
                        "metadata": doc['metadata']
                    }
                }

        success, failed = bulk(self.es, generate_docs())
        self.es.indices.refresh(index=self.index_name)

        return success, len(failed)

    def search(self, query, k=3, use_hybrid=True):
        """
        검색 수행

        Args:
            query (str): 검색 질문
            k (int): 반환 문서 수
            use_hybrid (bool): 하이브리드 검색 사용 여부

        Returns:
            list: 검색 결과
        """
        query_embedding = self.model.encode([query])[0]

        if use_hybrid:
            # 하이브리드 검색
            search_query = {
                "query": {
                    "bool": {
                        "should": [
                            {
                                "match": {
                                    "text": {
                                        "query": query,
                                        "boost": 0.3
                                    }
                                }
                            }
                        ]
                    }
                },
                "knn": {
                    "field": "embedding",
                    "query_vector": query_embedding.tolist(),
                    "k": k,
                    "num_candidates": 100,
                    "boost": 0.7
                },
                "_source": ["doc_id", "text", "metadata"],
                "size": k
            }
        else:
            # 벡터 검색만
            search_query = {
                "knn": {
                    "field": "embedding",
                    "query_vector": query_embedding.tolist(),
                    "k": k,
                    "num_candidates": 100
                },
                "_source": ["doc_id", "text", "metadata"]
            }

        response = self.es.search(index=self.index_name, body=search_query)

        results = []
        for hit in response['hits']['hits']:
            results.append({
                'doc_id': hit['_source']['doc_id'],
                'text': hit['_source']['text'],
                'score': hit['_score'],
                'metadata': hit['_source']['metadata']
            })

        return results

    def generate_context(self, query, k=3):
        """
        질문에 대한 컨텍스트 생성 (LLM에 전달할 문서)

        Args:
            query (str): 사용자 질문
            k (int): 검색할 문서 수

        Returns:
            str: 컨텍스트 텍스트
        """
        results = self.search(query, k=k)

        context = "다음은 관련 정보입니다:\n\n"
        for i, result in enumerate(results):
            context += f"[문서 {i+1}]\n"
            context += f"{result['text']}\n"
            context += f"(출처: {result['metadata']['source']})\n\n"

        return context


# RAG 시스템 사용 예시
rag = SmartFarmRAG(
    es_client=es,
    index_name=index_name,
    embedding_model=model
)

# 질문
user_query = "스마트팜에서 병충해를 어떻게 감지하나요?"

# 컨텍스트 생성
context = rag.generate_context(user_query, k=3)

print(f"사용자 질문: {user_query}\n")
print("=" * 60)
print(context)
print("=" * 60)

# LLM에 전달할 프롬프트 구성
prompt = f"""
다음 컨텍스트를 참고하여 질문에 답변해주세요.

{context}

질문: {user_query}

답변:
"""

print("\nLLM에 전달할 프롬프트:")
print(prompt)
```

**실행 결과**:
```
사용자 질문: 스마트팜에서 병충해를 어떻게 감지하나요?

============================================================
다음은 관련 정보입니다:

[문서 1]
AI 기술은 병충해를 조기에 감지하고 예측할 수 있습니다.
(출처: smartfarm_guide.pdf)

[문서 2]
센서를 통해 온도, 습도, CO2 농도를 실시간으로 측정합니다.
(출처: smartfarm_guide.pdf)

[문서 3]
빅데이터 분석을 통해 농작물의 최적 생육 환경을 예측합니다.
(출처: smartfarm_guide.pdf)

============================================================

LLM에 전달할 프롬프트:

다음 컨텍스트를 참고하여 질문에 답변해주세요.

...

질문: 스마트팜에서 병충해를 어떻게 감지하나요?

답변:
```

---

## 7. 성능 최적화

### 7.1. 인덱스 설정 최적화

```python
# 성능 최적화된 인덱스 설정
optimized_mapping = {
    "settings": {
        "index": {
            "number_of_shards": 1,  # 샤드 수 (작은 데이터셋)
            "number_of_replicas": 0,  # 복제본 (개발 환경)
            "refresh_interval": "30s"  # 새로고침 간격
        }
    },
    "mappings": {
        "properties": {
            "doc_id": {"type": "keyword"},
            "text": {
                "type": "text",
                "analyzer": "standard"
            },
            "embedding": {
                "type": "dense_vector",
                "dims": 768,
                "index": True,
                "similarity": "cosine",
                "index_options": {
                    "type": "hnsw",  # HNSW 알고리즘
                    "m": 16,  # 연결 수
                    "ef_construction": 100  # 구축 시 탐색 범위
                }
            },
            "metadata": {
                "properties": {
                    "source": {"type": "keyword"},
                    "category": {"type": "keyword"},
                    "created_at": {"type": "date"}
                }
            }
        }
    }
}

# 최적화된 인덱스 생성
optimized_index = 'smart_farm_optimized'
if es.indices.exists(index=optimized_index):
    es.indices.delete(index=optimized_index)

es.indices.create(index=optimized_index, body=optimized_mapping)
print(f"최적화된 인덱스 '{optimized_index}' 생성 완료")
```

### 7.2. 검색 성능 비교

```python
import time

def benchmark_search(query, iterations=10):
    """검색 성능 측정"""

    # 벡터 검색
    start = time.time()
    for _ in range(iterations):
        results = vector_search(query, k=5)
    vector_time = (time.time() - start) / iterations

    # 하이브리드 검색
    start = time.time()
    for _ in range(iterations):
        results = hybrid_search(query, k=5)
    hybrid_time = (time.time() - start) / iterations

    print(f"검색 성능 비교 ({iterations}회 평균):")
    print(f"  벡터 검색:      {vector_time:.4f}초")
    print(f"  하이브리드 검색: {hybrid_time:.4f}초")


# 벤치마크 실행
benchmark_search("스마트팜 센서 기술", iterations=10)
```

---

## 8. 다음 단계

Elasticsearch 벡터 검색을 익혔다면, 다음은 **인덱싱 최적화**입니다.

**다음 문서**: [1.2.09. Keylook API 활용한 인덱싱](./1.2.09.Keylook%20API%20활용한%20인덱싱.md)

### 다음에 배울 내용
- API 기반 문서 수집
- 자동 인덱싱 파이프라인
- 대량 데이터 처리
- 스케줄링 및 모니터링

---

**참고 자료**:
- Elasticsearch KNN Search: https://www.elastic.co/guide/en/elasticsearch/reference/current/knn-search.html
- Dense Vector Field Type: https://www.elastic.co/guide/en/elasticsearch/reference/current/dense-vector.html
- Sentence Transformers: https://www.sbert.net/
