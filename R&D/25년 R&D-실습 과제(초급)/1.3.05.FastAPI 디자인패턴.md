# 1.3.05. FastAPI 디자인패턴

> **작성자**: Bern
> **작성일**: 2025-10-26
> **카테고리**: 웹 프레임워크

---

## 목차
1. [디자인 패턴의 필요성](#1-디자인-패턴의-필요성)
2. [Router 패턴](#2-router-패턴)
3. [Service 패턴](#3-service-패턴)
4. [Repository 패턴](#4-repository-패턴)
5. [3계층 아키텍처 통합](#5-3계층-아키텍처-통합)
6. [실습 코드](#6-실습-코드)

---

## 1. 디자인 패턴의 필요성

### 1.1. 패턴 없는 코드의 문제점

```python
# ❌ 나쁜 예: 모든 로직이 라우터에 있음
@app.post("/users")
def create_user(user: UserCreate):
    # 유효성 검증
    if len(user.name) < 2:
        raise HTTPException(400, "Name too short")

    # 이메일 중복 체크 (DB 접근)
    conn = engine.connect()
    existing = conn.execute("SELECT * FROM users WHERE email = ?", user.email)
    if existing:
        raise HTTPException(400, "Email exists")

    # 비즈니스 로직
    hashed_password = hash_password(user.password)

    # DB 저장
    conn.execute("INSERT INTO users VALUES (?, ?, ?)", user.name, user.email, hashed_password)
    conn.commit()

    # 이메일 전송
    send_welcome_email(user.email)

    return {"message": "User created"}
```

**문제점**:
- 라우터가 너무 많은 책임을 가짐
- 코드 재사용 불가능
- 테스트 어려움
- 유지보수 어려움

### 1.2. 3계층 아키텍처 (Layered Architecture)

```
┌─────────────────────────────────────┐
│   Router (Presentation Layer)      │  ← HTTP 요청/응답 처리
│   - 요청 검증                        │
│   - 응답 형식화                      │
├─────────────────────────────────────┤
│   Service (Business Logic Layer)   │  ← 비즈니스 로직
│   - 업무 규칙                        │
│   - 데이터 가공                      │
├─────────────────────────────────────┤
│   Repository (Data Access Layer)   │  ← 데이터베이스 접근
│   - CRUD 작업                        │
│   - 쿼리 실행                        │
└─────────────────────────────────────┘
```

### 1.3. 각 계층의 역할

| 계층 | 역할 | 예시 |
|-----|------|------|
| **Router** | HTTP 요청/응답 처리 | 파라미터 검증, 상태 코드 반환 |
| **Service** | 비즈니스 로직 | 사용자 생성, 비밀번호 암호화, 이메일 전송 |
| **Repository** | 데이터 접근 | DB에서 조회, 삽입, 수정, 삭제 |

---

## 2. Router 패턴

### 2.1. Router의 역할

**Router는 HTTP 요청을 받아 적절한 Service를 호출하고 응답을 반환합니다.**

| 책임 | 설명 |
|-----|------|
| **요청 수신** | HTTP 요청 파라미터 파싱 |
| **검증** | 기본 데이터 검증 (Pydantic) |
| **Service 호출** | 비즈니스 로직 위임 |
| **응답 반환** | 상태 코드, 응답 형식화 |
| **에러 처리** | HTTP 예외 처리 |

### 2.2. Router 분리 (APIRouter)

```python
# routers/user_router.py
from fastapi import APIRouter, Depends, HTTPException, status

router = APIRouter(
    prefix="/users",
    tags=["users"]
)

@router.get("/")
def get_users():
    """사용자 목록 조회"""
    return {"users": []}

@router.post("/", status_code=status.HTTP_201_CREATED)
def create_user(user: UserCreate):
    """사용자 생성"""
    return {"message": "User created"}

@router.get("/{user_id}")
def get_user(user_id: int):
    """사용자 조회"""
    return {"id": user_id}
```

```python
# main.py
from fastapi import FastAPI
from routers import user_router, product_router

app = FastAPI()

# 라우터 등록
app.include_router(user_router.router)
app.include_router(product_router.router)
```

### 2.3. Router의 장점

| 장점 | 설명 |
|-----|------|
| **모듈화** | 기능별로 파일 분리 (users, products, orders 등) |
| **재사용** | 같은 라우터를 여러 앱에서 사용 가능 |
| **유지보수** | 관련 엔드포인트가 한 곳에 모임 |
| **테스트** | 라우터별로 독립적인 테스트 가능 |

### 2.4. 실무 예시 - 깔끔한 Router

```python
# routers/user_router.py
from fastapi import APIRouter, Depends, status
from services.user_service import UserService
from schemas.user_schema import UserCreate, UserResponse

router = APIRouter(prefix="/users", tags=["users"])

@router.post("/", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
def create_user(
    user: UserCreate,
    service: UserService = Depends()
):
    """
    사용자 생성
    - Router는 HTTP만 처리
    - 비즈니스 로직은 Service에 위임
    """
    return service.create_user(user)

@router.get("/{user_id}", response_model=UserResponse)
def get_user(
    user_id: int,
    service: UserService = Depends()
):
    """사용자 조회"""
    return service.get_user(user_id)
```

---

## 3. Service 패턴

### 3.1. Service의 역할

**Service는 비즈니스 로직을 담당합니다.**

| 책임 | 설명 |
|-----|------|
| **비즈니스 로직** | 업무 규칙 구현 |
| **데이터 가공** | 여러 Repository 조합 |
| **트랜잭션 관리** | DB 트랜잭션 제어 |
| **외부 서비스 호출** | 이메일, SMS 등 |
| **예외 처리** | 비즈니스 예외 발생 |

### 3.2. Service 구현 예시

```python
# services/user_service.py
from fastapi import HTTPException, status
from repositories.user_repository import UserRepository
from schemas.user_schema import UserCreate, UserUpdate
from utils.security import hash_password
from utils.email import send_welcome_email

class UserService:
    def __init__(self, repository: UserRepository = None):
        self.repository = repository or UserRepository()

    def create_user(self, user: UserCreate):
        """
        사용자 생성 비즈니스 로직
        1. 이메일 중복 체크
        2. 비밀번호 암호화
        3. DB 저장
        4. 환영 이메일 발송
        """
        # 1. 이메일 중복 체크
        existing = self.repository.find_by_email(user.email)
        if existing:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Email already registered"
            )

        # 2. 비밀번호 암호화
        hashed_password = hash_password(user.password)

        # 3. DB 저장
        user_data = {
            **user.dict(),
            "password": hashed_password
        }
        new_user = self.repository.create(user_data)

        # 4. 환영 이메일 발송 (비동기로 처리 권장)
        send_welcome_email(new_user.email)

        return new_user

    def get_user(self, user_id: int):
        """사용자 조회"""
        user = self.repository.find_by_id(user_id)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found"
            )
        return user

    def update_user(self, user_id: int, user_update: UserUpdate):
        """사용자 수정"""
        # 존재 확인
        existing = self.get_user(user_id)

        # 이메일 변경 시 중복 체크
        if user_update.email and user_update.email != existing.email:
            if self.repository.find_by_email(user_update.email):
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Email already in use"
                )

        # 업데이트
        return self.repository.update(user_id, user_update.dict(exclude_unset=True))

    def delete_user(self, user_id: int):
        """사용자 삭제"""
        # 존재 확인
        self.get_user(user_id)

        # 삭제 전 비즈니스 로직 (예: 주문 확인)
        # if self.order_repository.has_pending_orders(user_id):
        #     raise HTTPException(400, "Cannot delete user with pending orders")

        # 삭제
        self.repository.delete(user_id)
```

### 3.3. Service의 장점

| 장점 | 설명 |
|-----|------|
| **비즈니스 로직 집중** | 업무 규칙이 한 곳에 모임 |
| **재사용** | 여러 Router에서 같은 Service 사용 |
| **테스트 용이** | Repository를 Mock으로 대체 가능 |
| **트랜잭션 관리** | 여러 DB 작업을 하나의 트랜잭션으로 |

---

## 4. Repository 패턴

### 4.1. Repository의 역할

**Repository는 데이터베이스 접근을 캡슐화합니다.**

| 책임 | 설명 |
|-----|------|
| **CRUD 작업** | Create, Read, Update, Delete |
| **쿼리 실행** | SQL 또는 ORM 쿼리 |
| **데이터 매핑** | DB 레코드 ↔ 도메인 객체 |
| **DB 독립성** | DB 종류 변경 시 이 계층만 수정 |

### 4.2. Repository 구현 예시

```python
# repositories/user_repository.py
from sqlalchemy.orm import Session
from models.user_model import User
from typing import List, Optional

class UserRepository:
    def __init__(self, db: Session = None):
        self.db = db

    def create(self, user_data: dict) -> User:
        """사용자 생성"""
        user = User(**user_data)
        self.db.add(user)
        self.db.commit()
        self.db.refresh(user)
        return user

    def find_by_id(self, user_id: int) -> Optional[User]:
        """ID로 조회"""
        return self.db.query(User).filter(User.id == user_id).first()

    def find_by_email(self, email: str) -> Optional[User]:
        """이메일로 조회"""
        return self.db.query(User).filter(User.email == email).first()

    def find_all(self, skip: int = 0, limit: int = 100) -> List[User]:
        """전체 조회 (페이지네이션)"""
        return self.db.query(User).offset(skip).limit(limit).all()

    def update(self, user_id: int, update_data: dict) -> User:
        """사용자 수정"""
        user = self.find_by_id(user_id)
        for key, value in update_data.items():
            setattr(user, key, value)
        self.db.commit()
        self.db.refresh(user)
        return user

    def delete(self, user_id: int) -> None:
        """사용자 삭제"""
        user = self.find_by_id(user_id)
        self.db.delete(user)
        self.db.commit()

    def count(self) -> int:
        """전체 개수"""
        return self.db.query(User).count()

    def exists_by_email(self, email: str) -> bool:
        """이메일 존재 여부"""
        return self.db.query(User).filter(User.email == email).count() > 0
```

### 4.3. Repository의 장점

| 장점 | 설명 |
|-----|------|
| **DB 독립성** | MySQL → PostgreSQL 변경 시 이 계층만 수정 |
| **쿼리 재사용** | 같은 쿼리를 여러 곳에서 사용 |
| **테스트** | Mock Repository로 테스트 |
| **복잡한 쿼리** | SQL 로직을 한 곳에 집중 |

---

## 5. 3계층 아키텍처 통합

### 5.1. 전체 구조

```
project/
├── main.py                  # FastAPI 앱
├── models/                  # DB 모델
│   └── user_model.py
├── schemas/                 # Pydantic 스키마
│   └── user_schema.py
├── routers/                 # Router 계층
│   └── user_router.py
├── services/                # Service 계층
│   └── user_service.py
├── repositories/            # Repository 계층
│   └── user_repository.py
└── database.py              # DB 연결
```

### 5.2. 각 계층의 코드

#### Model (DB)
```python
# models/user_model.py
from sqlalchemy import Column, Integer, String, Boolean
from database import Base

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(50), nullable=False)
    email = Column(String(100), unique=True, nullable=False)
    password = Column(String(255), nullable=False)
    is_active = Column(Boolean, default=True)
```

#### Schema (Pydantic)
```python
# schemas/user_schema.py
from pydantic import BaseModel, EmailStr

class UserCreate(BaseModel):
    name: str
    email: EmailStr
    password: str

class UserUpdate(BaseModel):
    name: str | None = None
    email: EmailStr | None = None

class UserResponse(BaseModel):
    id: int
    name: str
    email: str
    is_active: bool

    class Config:
        from_attributes = True
```

#### Repository
```python
# repositories/user_repository.py
from sqlalchemy.orm import Session
from models.user_model import User

class UserRepository:
    def __init__(self, db: Session):
        self.db = db

    def create(self, user_data: dict):
        user = User(**user_data)
        self.db.add(user)
        self.db.commit()
        self.db.refresh(user)
        return user

    def find_by_id(self, user_id: int):
        return self.db.query(User).filter(User.id == user_id).first()

    def find_by_email(self, email: str):
        return self.db.query(User).filter(User.email == email).first()

    def update(self, user_id: int, update_data: dict):
        user = self.find_by_id(user_id)
        for key, value in update_data.items():
            setattr(user, key, value)
        self.db.commit()
        self.db.refresh(user)
        return user

    def delete(self, user_id: int):
        user = self.find_by_id(user_id)
        self.db.delete(user)
        self.db.commit()
```

#### Service
```python
# services/user_service.py
from fastapi import HTTPException, status
from repositories.user_repository import UserRepository
from schemas.user_schema import UserCreate, UserUpdate

class UserService:
    def __init__(self, repository: UserRepository):
        self.repository = repository

    def create_user(self, user: UserCreate):
        # 이메일 중복 체크
        if self.repository.find_by_email(user.email):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Email already exists"
            )

        # 비밀번호 해시 (실제로는 bcrypt 사용)
        user_data = user.dict()
        user_data["password"] = f"hashed_{user.password}"

        return self.repository.create(user_data)

    def get_user(self, user_id: int):
        user = self.repository.find_by_id(user_id)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found"
            )
        return user

    def update_user(self, user_id: int, user_update: UserUpdate):
        self.get_user(user_id)  # 존재 확인
        update_data = user_update.dict(exclude_unset=True)
        return self.repository.update(user_id, update_data)

    def delete_user(self, user_id: int):
        self.get_user(user_id)  # 존재 확인
        self.repository.delete(user_id)
```

#### Router
```python
# routers/user_router.py
from fastapi import APIRouter, Depends, status
from sqlalchemy.orm import Session
from database import get_db
from services.user_service import UserService
from repositories.user_repository import UserRepository
from schemas.user_schema import UserCreate, UserUpdate, UserResponse

router = APIRouter(prefix="/users", tags=["users"])

def get_user_service(db: Session = Depends(get_db)):
    repository = UserRepository(db)
    return UserService(repository)

@router.post("/", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
def create_user(
    user: UserCreate,
    service: UserService = Depends(get_user_service)
):
    """사용자 생성"""
    return service.create_user(user)

@router.get("/{user_id}", response_model=UserResponse)
def get_user(
    user_id: int,
    service: UserService = Depends(get_user_service)
):
    """사용자 조회"""
    return service.get_user(user_id)

@router.patch("/{user_id}", response_model=UserResponse)
def update_user(
    user_id: int,
    user_update: UserUpdate,
    service: UserService = Depends(get_user_service)
):
    """사용자 수정"""
    return service.update_user(user_id, user_update)

@router.delete("/{user_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_user(
    user_id: int,
    service: UserService = Depends(get_user_service)
):
    """사용자 삭제"""
    service.delete_user(user_id)
```

#### Main
```python
# main.py
from fastapi import FastAPI
from routers import user_router
from database import engine, Base

# 테이블 생성
Base.metadata.create_all(bind=engine)

app = FastAPI(title="3-Tier Architecture API")

# 라우터 등록
app.include_router(user_router.router)

@app.get("/")
def root():
    return {"message": "3-Tier Architecture API"}
```

### 5.3. 데이터 흐름

```
1. 요청: POST /users
   ↓
2. Router: create_user() 함수 호출
   ↓
3. Service.create_user()
   - 이메일 중복 체크 (Repository 호출)
   - 비밀번호 암호화
   - Repository.create() 호출
   ↓
4. Repository.create()
   - DB에 INSERT
   ↓
5. 응답: 201 Created + UserResponse
```

### 5.4. 장단점 비교

#### 장점

| 장점 | 설명 |
|-----|------|
| **관심사 분리** | 각 계층이 명확한 책임을 가짐 |
| **유지보수** | 수정 시 해당 계층만 변경 |
| **테스트** | 각 계층을 독립적으로 테스트 |
| **확장성** | 새로운 기능 추가 용이 |
| **팀 협업** | 계층별로 작업 분담 가능 |

#### 단점

| 단점 | 설명 |
|-----|------|
| **복잡도 증가** | 간단한 기능도 3개 파일 필요 |
| **보일러플레이트** | 반복적인 코드 증가 |
| **러닝 커브** | 초보자에게 어려울 수 있음 |
| **오버 엔지니어링** | 작은 프로젝트에는 과할 수 있음 |

### 5.5. 언제 사용할까?

| 프로젝트 규모 | 권장 패턴 |
|-------------|----------|
| **소규모** (API 10개 미만) | Router만 사용 |
| **중규모** (API 10-50개) | Router + Service |
| **대규모** (API 50개 이상) | Router + Service + Repository |

---

## 6. 실습 코드

### 6.1. 완전한 3계층 아키텍처

```python
# database.py
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

SQLALCHEMY_DATABASE_URL = "sqlite:///./users.db"

engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

```python
# models/user_model.py
from sqlalchemy import Column, Integer, String, Boolean
from database import Base

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(50))
    email = Column(String(100), unique=True)
    password = Column(String(255))
    is_active = Column(Boolean, default=True)
```

```python
# schemas/user_schema.py
from pydantic import BaseModel, EmailStr

class UserCreate(BaseModel):
    name: str
    email: EmailStr
    password: str

class UserUpdate(BaseModel):
    name: str | None = None
    email: EmailStr | None = None

class UserResponse(BaseModel):
    id: int
    name: str
    email: str
    is_active: bool

    class Config:
        from_attributes = True
```

```python
# repositories/user_repository.py
from sqlalchemy.orm import Session
from models.user_model import User

class UserRepository:
    def __init__(self, db: Session):
        self.db = db

    def create(self, user_data: dict):
        user = User(**user_data)
        self.db.add(user)
        self.db.commit()
        self.db.refresh(user)
        return user

    def find_by_id(self, user_id: int):
        return self.db.query(User).filter(User.id == user_id).first()

    def find_by_email(self, email: str):
        return self.db.query(User).filter(User.email == email).first()

    def find_all(self):
        return self.db.query(User).all()

    def update(self, user_id: int, update_data: dict):
        user = self.find_by_id(user_id)
        for key, value in update_data.items():
            setattr(user, key, value)
        self.db.commit()
        self.db.refresh(user)
        return user

    def delete(self, user_id: int):
        user = self.find_by_id(user_id)
        self.db.delete(user)
        self.db.commit()
```

```python
# services/user_service.py
from fastapi import HTTPException, status
from repositories.user_repository import UserRepository
from schemas.user_schema import UserCreate, UserUpdate

class UserService:
    def __init__(self, repository: UserRepository):
        self.repository = repository

    def create_user(self, user: UserCreate):
        if self.repository.find_by_email(user.email):
            raise HTTPException(status.HTTP_400_BAD_REQUEST, "Email exists")

        user_data = user.dict()
        user_data["password"] = f"hashed_{user.password}"
        return self.repository.create(user_data)

    def get_user(self, user_id: int):
        user = self.repository.find_by_id(user_id)
        if not user:
            raise HTTPException(status.HTTP_404_NOT_FOUND, "User not found")
        return user

    def get_all_users(self):
        return self.repository.find_all()

    def update_user(self, user_id: int, user_update: UserUpdate):
        self.get_user(user_id)
        return self.repository.update(user_id, user_update.dict(exclude_unset=True))

    def delete_user(self, user_id: int):
        self.get_user(user_id)
        self.repository.delete(user_id)
```

```python
# routers/user_router.py
from fastapi import APIRouter, Depends, status
from sqlalchemy.orm import Session
from database import get_db
from services.user_service import UserService
from repositories.user_repository import UserRepository
from schemas.user_schema import UserCreate, UserUpdate, UserResponse
from typing import List

router = APIRouter(prefix="/users", tags=["users"])

def get_service(db: Session = Depends(get_db)):
    return UserService(UserRepository(db))

@router.post("/", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
def create_user(user: UserCreate, service: UserService = Depends(get_service)):
    return service.create_user(user)

@router.get("/", response_model=List[UserResponse])
def get_users(service: UserService = Depends(get_service)):
    return service.get_all_users()

@router.get("/{user_id}", response_model=UserResponse)
def get_user(user_id: int, service: UserService = Depends(get_service)):
    return service.get_user(user_id)

@router.patch("/{user_id}", response_model=UserResponse)
def update_user(user_id: int, user: UserUpdate, service: UserService = Depends(get_service)):
    return service.update_user(user_id, user)

@router.delete("/{user_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_user(user_id: int, service: UserService = Depends(get_service)):
    service.delete_user(user_id)
```

```python
# main.py
from fastapi import FastAPI
from routers import user_router
from database import engine, Base

Base.metadata.create_all(bind=engine)

app = FastAPI(title="3-Tier Architecture API")
app.include_router(user_router.router)

@app.get("/")
def root():
    return {"message": "API with 3-Tier Architecture"}

# 실행: uvicorn main:app --reload
```

### 6.2. 실행 및 테스트

```bash
# 설치
pip install fastapi uvicorn sqlalchemy pydantic[email]

# 실행
uvicorn main:app --reload

# 테스트
curl -X POST http://localhost:8000/users \
  -H "Content-Type: application/json" \
  -d '{"name":"홍길동","email":"hong@test.com","password":"1234"}'

curl http://localhost:8000/users
```

---

## 다음 단계

FastAPI 디자인 패턴을 이해했다면, 다음 단계에서는 **로그 설정**을 통해 애플리케이션을 모니터링하는 방법을 배워보겠습니다.

**다음 문서**: [1.3.06. FastAPI Log](./1.3.06.FastAPI%20Log.md)

### 다음에 배울 내용
- 로그 레벨 설정
- 로그 포맷 지정
- 파일 로그 저장
- 요청/응답 로깅
- 실전 로깅 전략

---

**참고 자료**:
- FastAPI 의존성 주입: https://fastapi.tiangolo.com/tutorial/dependencies/
- Layered Architecture: https://martinfowler.com/bliki/PresentationDomainDataLayering.html
- Repository Pattern: https://martinfowler.com/eaaCatalog/repository.html
