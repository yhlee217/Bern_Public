# 1.3.04. FastAPI API 만들기

> **작성자**: Bern
> **작성일**: 2025-10-26
> **카테고리**: 웹 프레임워크

---

## 목차
1. [HTTP 메서드 개요](#1-http-메서드-개요)
2. [GET - 데이터 조회](#2-get---데이터-조회)
3. [POST - 데이터 생성](#3-post---데이터-생성)
4. [PUT / PATCH - 데이터 수정](#4-put--patch---데이터-수정)
5. [DELETE - 데이터 삭제](#5-delete---데이터-삭제)
6. [HTTP 데이터 전송](#6-http-데이터-전송)
7. [API Return 정보 작성](#7-api-return-정보-작성)
8. [실습 코드](#8-실습-코드)

---

## 1. HTTP 메서드 개요

### 1.1. HTTP 메서드란?

HTTP 메서드(Method)는 클라이언트가 서버에 요청하는 작업의 종류를 나타냅니다.

| 메서드 | 의미 | CRUD | 용도 |
|-------|------|------|------|
| **GET** | 조회 | Read | 리소스 조회 |
| **POST** | 생성 | Create | 리소스 생성 |
| **PUT** | 전체 수정 | Update | 리소스 전체 교체 |
| **PATCH** | 부분 수정 | Update | 리소스 일부 수정 |
| **DELETE** | 삭제 | Delete | 리소스 삭제 |

### 1.2. RESTful API 원칙

```
리소스(명사) + HTTP 메서드(동사)

예시:
GET    /users        → 사용자 목록 조회
GET    /users/1      → ID가 1인 사용자 조회
POST   /users        → 새 사용자 생성
PUT    /users/1      → ID가 1인 사용자 전체 수정
PATCH  /users/1      → ID가 1인 사용자 일부 수정
DELETE /users/1      → ID가 1인 사용자 삭제
```

### 1.3. FastAPI 기본 구조

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def read_root():
    return {"message": "Hello World"}

@app.get("/items/{item_id}")
def read_item(item_id: int):
    return {"item_id": item_id}
```

---

## 2. GET - 데이터 조회

### 2.1. GET의 특징

| 특징 | 설명 |
|-----|------|
| **용도** | 리소스 조회 |
| **데이터 전송** | URL의 Query Parameter |
| **안전성** | Safe (서버 상태 변경 없음) |
| **멱등성** | Idempotent (여러 번 호출해도 같은 결과) |
| **캐싱** | 가능 |

### 2.2. 기본 GET 예시

```python
from fastapi import FastAPI

app = FastAPI()

# 1. 기본 조회
@app.get("/")
def root():
    return {"message": "Welcome to API"}

# 2. Path Parameter
@app.get("/users/{user_id}")
def get_user(user_id: int):
    return {"user_id": user_id, "name": "홍길동"}

# 3. Query Parameter
@app.get("/items")
def get_items(skip: int = 0, limit: int = 10):
    return {"skip": skip, "limit": limit}

# 4. 여러 Query Parameter
@app.get("/search")
def search(q: str, category: str = None, min_price: int = 0):
    return {
        "query": q,
        "category": category,
        "min_price": min_price
    }
```

### 2.3. 실무 예시 - 사용자 목록 조회

```python
from typing import List, Optional
from fastapi import FastAPI, Query

app = FastAPI()

# 가상의 데이터베이스
users_db = [
    {"id": 1, "name": "홍길동", "age": 25, "city": "서울"},
    {"id": 2, "name": "김철수", "age": 30, "city": "부산"},
    {"id": 3, "name": "이영희", "age": 28, "city": "서울"}
]

@app.get("/users")
def get_users(
    skip: int = Query(0, ge=0, description="건너뛸 개수"),
    limit: int = Query(10, ge=1, le=100, description="조회할 개수"),
    city: Optional[str] = Query(None, description="도시 필터")
):
    """
    사용자 목록 조회
    - skip: 페이지네이션 오프셋
    - limit: 한 번에 조회할 개수
    - city: 도시로 필터링 (선택)
    """
    filtered = users_db

    # 도시 필터
    if city:
        filtered = [u for u in filtered if u["city"] == city]

    # 페이지네이션
    result = filtered[skip : skip + limit]

    return {
        "total": len(filtered),
        "skip": skip,
        "limit": limit,
        "data": result
    }

@app.get("/users/{user_id}")
def get_user(user_id: int):
    """특정 사용자 조회"""
    user = next((u for u in users_db if u["id"] == user_id), None)
    if not user:
        return {"error": "User not found"}, 404
    return user
```

### 2.4. 사용 결과

```bash
# 기본 조회
GET http://localhost:8000/users
Response:
{
  "total": 3,
  "skip": 0,
  "limit": 10,
  "data": [
    {"id": 1, "name": "홍길동", "age": 25, "city": "서울"},
    {"id": 2, "name": "김철수", "age": 30, "city": "부산"},
    {"id": 3, "name": "이영희", "age": 28, "city": "서울"}
  ]
}

# 도시 필터링
GET http://localhost:8000/users?city=서울
Response:
{
  "total": 2,
  "skip": 0,
  "limit": 10,
  "data": [
    {"id": 1, "name": "홍길동", "age": 25, "city": "서울"},
    {"id": 3, "name": "이영희", "age": 28, "city": "서울"}
  ]
}

# 특정 사용자
GET http://localhost:8000/users/1
Response:
{"id": 1, "name": "홍길동", "age": 25, "city": "서울"}
```

---

## 3. POST - 데이터 생성

### 3.1. POST의 특징

| 특징 | 설명 |
|-----|------|
| **용도** | 리소스 생성 |
| **데이터 전송** | Request Body (JSON, Form 등) |
| **안전성** | Not Safe (서버 상태 변경) |
| **멱등성** | Not Idempotent (여러 번 호출 시 리소스 여러 개 생성) |
| **캐싱** | 불가능 |

### 3.2. 기본 POST 예시

```python
from pydantic import BaseModel

class User(BaseModel):
    name: str
    email: str
    age: int

@app.post("/users")
def create_user(user: User):
    return {
        "message": "User created",
        "user": user
    }
```

### 3.3. 실무 예시 - 사용자 생성

```python
from fastapi import FastAPI, HTTPException, status
from pydantic import BaseModel, EmailStr, Field
from typing import List

app = FastAPI()

# 요청 모델
class UserCreate(BaseModel):
    name: str = Field(..., min_length=2, max_length=50, description="사용자 이름")
    email: EmailStr = Field(..., description="이메일 주소")
    age: int = Field(..., ge=0, le=150, description="나이")
    city: str = Field(..., min_length=2, description="도시")

# 응답 모델
class UserResponse(BaseModel):
    id: int
    name: str
    email: str
    age: int
    city: str

# 데이터베이스 (메모리)
users_db: List[dict] = []
user_id_counter = 1

@app.post("/users", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
def create_user(user: UserCreate):
    """
    새로운 사용자 생성

    - name: 2-50자 사이의 이름
    - email: 유효한 이메일 주소
    - age: 0-150 사이의 나이
    - city: 도시 이름
    """
    global user_id_counter

    # 이메일 중복 체크
    if any(u["email"] == user.email for u in users_db):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered"
        )

    # 새 사용자 생성
    new_user = {
        "id": user_id_counter,
        **user.dict()
    }
    users_db.append(new_user)
    user_id_counter += 1

    return new_user
```

### 3.4. 사용 결과

```bash
# 사용자 생성
POST http://localhost:8000/users
Content-Type: application/json

{
  "name": "홍길동",
  "email": "hong@example.com",
  "age": 25,
  "city": "서울"
}

Response (201 Created):
{
  "id": 1,
  "name": "홍길동",
  "email": "hong@example.com",
  "age": 25,
  "city": "서울"
}

# 중복 이메일로 시도
POST http://localhost:8000/users
{
  "name": "김철수",
  "email": "hong@example.com",  # 중복
  "age": 30,
  "city": "부산"
}

Response (400 Bad Request):
{
  "detail": "Email already registered"
}
```

---

## 4. PUT / PATCH - 데이터 수정

### 4.1. PUT vs PATCH

| 비교 | PUT | PATCH |
|-----|-----|-------|
| **의미** | 전체 교체 | 부분 수정 |
| **데이터** | 전체 필드 필요 | 수정할 필드만 필요 |
| **멱등성** | Idempotent | Idempotent |
| **실무 사용** | 덜 사용됨 | 자주 사용됨 |

### 4.2. PUT 예시 (전체 수정)

```python
from pydantic import BaseModel

class UserUpdate(BaseModel):
    name: str
    email: str
    age: int
    city: str

@app.put("/users/{user_id}")
def update_user(user_id: int, user: UserUpdate):
    """사용자 정보 전체 교체"""
    # 기존 사용자 찾기
    existing = next((u for u in users_db if u["id"] == user_id), None)
    if not existing:
        raise HTTPException(status_code=404, detail="User not found")

    # 전체 교체 (ID만 유지)
    updated_user = {"id": user_id, **user.dict()}
    users_db[users_db.index(existing)] = updated_user

    return updated_user
```

### 4.3. PATCH 예시 (부분 수정)

```python
from pydantic import BaseModel
from typing import Optional

class UserPatch(BaseModel):
    name: Optional[str] = None
    email: Optional[EmailStr] = None
    age: Optional[int] = None
    city: Optional[str] = None

@app.patch("/users/{user_id}")
def patch_user(user_id: int, user: UserPatch):
    """사용자 정보 부분 수정"""
    # 기존 사용자 찾기
    existing = next((u for u in users_db if u["id"] == user_id), None)
    if not existing:
        raise HTTPException(status_code=404, detail="User not found")

    # 제공된 필드만 업데이트
    update_data = user.dict(exclude_unset=True)
    for field, value in update_data.items():
        existing[field] = value

    return existing
```

### 4.4. 사용 결과

```bash
# PUT - 전체 수정 (모든 필드 필요)
PUT http://localhost:8000/users/1
{
  "name": "홍길동",
  "email": "hong_new@example.com",
  "age": 26,
  "city": "인천"
}

Response:
{
  "id": 1,
  "name": "홍길동",
  "email": "hong_new@example.com",
  "age": 26,
  "city": "인천"
}

# PATCH - 부분 수정 (일부 필드만)
PATCH http://localhost:8000/users/1
{
  "age": 27
}

Response:
{
  "id": 1,
  "name": "홍길동",
  "email": "hong_new@example.com",
  "age": 27,  # age만 변경됨
  "city": "인천"
}
```

---

## 5. DELETE - 데이터 삭제

### 5.1. DELETE의 특징

| 특징 | 설명 |
|-----|------|
| **용도** | 리소스 삭제 |
| **데이터 전송** | Path Parameter |
| **안전성** | Not Safe (서버 상태 변경) |
| **멱등성** | Idempotent (여러 번 삭제해도 결과 동일) |
| **응답** | 204 No Content 또는 200 OK |

### 5.2. 기본 DELETE 예시

```python
@app.delete("/users/{user_id}")
def delete_user(user_id: int):
    """사용자 삭제"""
    user = next((u for u in users_db if u["id"] == user_id), None)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    users_db.remove(user)
    return {"message": "User deleted successfully"}
```

### 5.3. 실무 예시 - Soft Delete

```python
from datetime import datetime

@app.delete("/users/{user_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_user(user_id: int):
    """
    사용자 삭제 (Soft Delete)
    실제로는 삭제하지 않고 deleted_at 필드만 업데이트
    """
    user = next((u for u in users_db if u["id"] == user_id), None)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    # Soft Delete
    user["deleted_at"] = datetime.now().isoformat()
    user["is_active"] = False

    return  # 204 No Content는 body 없음

@app.delete("/users/{user_id}/permanent")
def permanent_delete_user(user_id: int):
    """영구 삭제 (Hard Delete)"""
    user = next((u for u in users_db if u["id"] == user_id), None)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    users_db.remove(user)
    return {"message": f"User {user_id} permanently deleted"}
```

### 5.4. 사용 결과

```bash
# Soft Delete
DELETE http://localhost:8000/users/1

Response (204 No Content):
# 응답 본문 없음

# Hard Delete
DELETE http://localhost:8000/users/1/permanent

Response (200 OK):
{
  "message": "User 1 permanently deleted"
}

# 없는 사용자 삭제
DELETE http://localhost:8000/users/999

Response (404 Not Found):
{
  "detail": "User not found"
}
```

---

## 6. HTTP 데이터 전송

### 6.1. 데이터 전송 방법 비교

| 방법 | 전송 위치 | Content-Type | 용도 |
|-----|---------|--------------|------|
| **Body()** | Request Body | `application/json` | JSON 데이터 |
| **Query()** | URL Query String | - | 필터, 페이지네이션 |
| **Path()** | URL Path | - | 리소스 식별자 |
| **Header()** | HTTP Header | - | 인증, 메타데이터 |
| **Form()** | Request Body | `application/x-www-form-urlencoded` | HTML 폼 |
| **File()** | Request Body | `multipart/form-data` | 파일 업로드 |

### 6.2. Body() - JSON 데이터

```python
from fastapi import Body
from pydantic import BaseModel

class Item(BaseModel):
    name: str
    price: float
    description: str = None

@app.post("/items")
def create_item(item: Item = Body(...)):
    """
    Request Body로 JSON 전송
    Content-Type: application/json
    """
    return {"item": item}

# 사용 예시
POST /items
Content-Type: application/json

{
  "name": "노트북",
  "price": 1000000,
  "description": "고성능 노트북"
}
```

**Body() 특징**:
- Content-Type: `application/json`
- 복잡한 데이터 구조 전송 가능
- Pydantic 모델로 자동 검증
- POST, PUT, PATCH에서 주로 사용

### 6.3. Query() - URL 쿼리 파라미터

```python
from fastapi import Query
from typing import Optional, List

@app.get("/items")
def get_items(
    q: Optional[str] = Query(None, min_length=3, max_length=50, description="검색어"),
    page: int = Query(1, ge=1, description="페이지 번호"),
    size: int = Query(10, ge=1, le=100, description="페이지 크기"),
    tags: List[str] = Query([], description="태그 필터")
):
    """
    Query Parameter로 데이터 전송
    URL: /items?q=노트북&page=1&size=10&tags=전자제품&tags=컴퓨터
    """
    return {
        "q": q,
        "page": page,
        "size": size,
        "tags": tags
    }
```

**사용 예시**:
```bash
GET /items?q=노트북&page=2&size=20&tags=전자제품&tags=컴퓨터

Response:
{
  "q": "노트북",
  "page": 2,
  "size": 20,
  "tags": ["전자제품", "컴퓨터"]
}
```

**Query() 특징**:
- URL에 노출됨 (보안에 주의)
- GET 요청에서 주로 사용
- 필터링, 정렬, 페이지네이션에 적합
- 배열 전달 가능 (`tags=a&tags=b`)

### 6.4. Form() - HTML 폼 데이터

```python
from fastapi import Form

@app.post("/login")
def login(
    username: str = Form(...),
    password: str = Form(...)
):
    """
    Form Data로 전송
    Content-Type: application/x-www-form-urlencoded
    """
    return {"username": username}

# 사용 예시
POST /login
Content-Type: application/x-www-form-urlencoded

username=hong&password=1234
```

**Form() 특징**:
- Content-Type: `application/x-www-form-urlencoded`
- HTML `<form>` 태그에서 전송
- 로그인, 회원가입 등에 사용
- 파일 업로드와 함께 사용 가능

### 6.5. File() - 파일 업로드

```python
from fastapi import File, UploadFile
from typing import List

@app.post("/upload")
async def upload_file(file: UploadFile = File(...)):
    """
    단일 파일 업로드
    Content-Type: multipart/form-data
    """
    contents = await file.read()
    return {
        "filename": file.filename,
        "content_type": file.content_type,
        "size": len(contents)
    }

@app.post("/upload-multiple")
async def upload_multiple(files: List[UploadFile] = File(...)):
    """여러 파일 업로드"""
    result = []
    for file in files:
        contents = await file.read()
        result.append({
            "filename": file.filename,
            "size": len(contents)
        })
    return {"files": result}
```

**사용 예시**:
```bash
POST /upload
Content-Type: multipart/form-data

file=@image.png

Response:
{
  "filename": "image.png",
  "content_type": "image/png",
  "size": 102400
}
```

**File() 특징**:
- Content-Type: `multipart/form-data`
- 이미지, 문서 등 파일 업로드
- async/await 사용 권장
- UploadFile 타입 사용 (SpooledTemporaryFile)

### 6.6. 혼합 사용 예시

```python
from fastapi import File, Form, UploadFile

@app.post("/items-with-image")
async def create_item_with_image(
    name: str = Form(...),
    price: float = Form(...),
    image: UploadFile = File(...)
):
    """
    Form 데이터 + 파일 동시 전송
    Content-Type: multipart/form-data
    """
    return {
        "name": name,
        "price": price,
        "image_filename": image.filename
    }
```

**사용 예시**:
```bash
POST /items-with-image
Content-Type: multipart/form-data

name=노트북
price=1000000
image=@laptop.jpg

Response:
{
  "name": "노트북",
  "price": 1000000,
  "image_filename": "laptop.jpg"
}
```

---

## 7. API Return 정보 작성

### 7.1. 기본 응답

```python
@app.get("/users/{user_id}")
def get_user(user_id: int):
    return {"id": user_id, "name": "홍길동"}
```

### 7.2. 상태 코드 지정

```python
from fastapi import status

@app.post("/users", status_code=status.HTTP_201_CREATED)
def create_user(user: User):
    return {"id": 1, **user.dict()}

@app.delete("/users/{user_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_user(user_id: int):
    return  # 204는 본문 없음
```

**주요 상태 코드**:
| 코드 | 의미 | 사용 예시 |
|-----|------|----------|
| 200 | OK | 성공적인 GET, PUT, PATCH |
| 201 | Created | 리소스 생성 성공 (POST) |
| 204 | No Content | 삭제 성공 (DELETE) |
| 400 | Bad Request | 잘못된 요청 |
| 401 | Unauthorized | 인증 필요 |
| 403 | Forbidden | 권한 없음 |
| 404 | Not Found | 리소스 없음 |
| 500 | Internal Server Error | 서버 오류 |

### 7.3. 응답 모델 정의

```python
from pydantic import BaseModel

class UserResponse(BaseModel):
    id: int
    name: str
    email: str

@app.get("/users/{user_id}", response_model=UserResponse)
def get_user(user_id: int):
    # 실제 DB에는 password도 있지만
    user_data = {
        "id": user_id,
        "name": "홍길동",
        "email": "hong@test.com",
        "password": "secret123"  # 응답에서 제외됨
    }
    return user_data  # response_model에 따라 필터링됨
```

### 7.4. 다양한 응답 예시

```python
from typing import List
from fastapi.responses import JSONResponse

# 1. 리스트 응답
@app.get("/users", response_model=List[UserResponse])
def get_users():
    return [
        {"id": 1, "name": "홍길동", "email": "hong@test.com"},
        {"id": 2, "name": "김철수", "email": "kim@test.com"}
    ]

# 2. 페이지네이션 응답
class PaginatedResponse(BaseModel):
    total: int
    page: int
    size: int
    data: List[UserResponse]

@app.get("/users/paginated", response_model=PaginatedResponse)
def get_users_paginated(page: int = 1, size: int = 10):
    return {
        "total": 100,
        "page": page,
        "size": size,
        "data": [...]
    }

# 3. 에러 응답
@app.get("/users/{user_id}")
def get_user(user_id: int):
    if user_id not in users_db:
        return JSONResponse(
            status_code=404,
            content={"error": "User not found", "user_id": user_id}
        )
    return users_db[user_id]

# 4. 커스텀 응답
class ApiResponse(BaseModel):
    success: bool
    message: str
    data: dict = None

@app.post("/users", response_model=ApiResponse)
def create_user(user: User):
    return {
        "success": True,
        "message": "User created successfully",
        "data": {"id": 1, **user.dict()}
    }
```

### 7.5. 응답 문서화

```python
from typing import Union

@app.get(
    "/users/{user_id}",
    response_model=UserResponse,
    responses={
        200: {
            "description": "Successful Response",
            "content": {
                "application/json": {
                    "example": {
                        "id": 1,
                        "name": "홍길동",
                        "email": "hong@test.com"
                    }
                }
            }
        },
        404: {
            "description": "User not found",
            "content": {
                "application/json": {
                    "example": {"detail": "User not found"}
                }
            }
        }
    }
)
def get_user(user_id: int):
    """
    사용자 정보 조회

    - **user_id**: 사용자 ID (필수)

    Returns:
        UserResponse: 사용자 정보
    """
    pass
```

---

## 8. 실습 코드

### 8.1. 완전한 CRUD API

```python
# main.py
import sys, io
if sys.platform == 'win32':
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')

from fastapi import FastAPI, HTTPException, status, Query
from pydantic import BaseModel, EmailStr, Field
from typing import List, Optional

app = FastAPI(title="User Management API", version="1.0.0")

# 모델 정의
class UserCreate(BaseModel):
    name: str = Field(..., min_length=2, max_length=50)
    email: EmailStr
    age: int = Field(..., ge=0, le=150)

class UserUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=2, max_length=50)
    email: Optional[EmailStr] = None
    age: Optional[int] = Field(None, ge=0, le=150)

class UserResponse(BaseModel):
    id: int
    name: str
    email: str
    age: int

# 데이터베이스 (메모리)
users_db: List[dict] = []
user_id_counter = 1

# ===== GET =====

@app.get("/")
def root():
    """API 루트"""
    return {"message": "User Management API", "version": "1.0.0"}

@app.get("/users", response_model=List[UserResponse])
def get_users(
    skip: int = Query(0, ge=0),
    limit: int = Query(10, ge=1, le=100),
    name: Optional[str] = None
):
    """사용자 목록 조회"""
    filtered = users_db

    if name:
        filtered = [u for u in filtered if name.lower() in u["name"].lower()]

    return filtered[skip : skip + limit]

@app.get("/users/{user_id}", response_model=UserResponse)
def get_user(user_id: int):
    """특정 사용자 조회"""
    user = next((u for u in users_db if u["id"] == user_id), None)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return user

# ===== POST =====

@app.post("/users", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
def create_user(user: UserCreate):
    """새 사용자 생성"""
    global user_id_counter

    # 이메일 중복 체크
    if any(u["email"] == user.email for u in users_db):
        raise HTTPException(status_code=400, detail="Email already exists")

    new_user = {"id": user_id_counter, **user.dict()}
    users_db.append(new_user)
    user_id_counter += 1

    return new_user

# ===== PATCH =====

@app.patch("/users/{user_id}", response_model=UserResponse)
def update_user(user_id: int, user: UserUpdate):
    """사용자 정보 수정"""
    existing = next((u for u in users_db if u["id"] == user_id), None)
    if not existing:
        raise HTTPException(status_code=404, detail="User not found")

    # 제공된 필드만 업데이트
    update_data = user.dict(exclude_unset=True)

    # 이메일 변경 시 중복 체크
    if "email" in update_data:
        if any(u["email"] == update_data["email"] and u["id"] != user_id for u in users_db):
            raise HTTPException(status_code=400, detail="Email already exists")

    for field, value in update_data.items():
        existing[field] = value

    return existing

# ===== DELETE =====

@app.delete("/users/{user_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_user(user_id: int):
    """사용자 삭제"""
    user = next((u for u in users_db if u["id"] == user_id), None)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    users_db.remove(user)
    return

# 실행: uvicorn main:app --reload
```

### 8.2. 테스트 스크립트

```python
# test_api.py
import requests
import json

BASE_URL = "http://localhost:8000"

def test_api():
    print("=== FastAPI CRUD 테스트 ===\n")

    # 1. POST - 사용자 생성
    print("1. POST /users (사용자 생성)")
    response = requests.post(f"{BASE_URL}/users", json={
        "name": "홍길동",
        "email": "hong@test.com",
        "age": 25
    })
    print(f"Status: {response.status_code}")
    print(f"Response: {response.json()}\n")

    user_id = response.json()["id"]

    # 2. GET - 사용자 조회
    print(f"2. GET /users/{user_id} (사용자 조회)")
    response = requests.get(f"{BASE_URL}/users/{user_id}")
    print(f"Status: {response.status_code}")
    print(f"Response: {response.json()}\n")

    # 3. PATCH - 사용자 수정
    print(f"3. PATCH /users/{user_id} (나이 수정)")
    response = requests.patch(f"{BASE_URL}/users/{user_id}", json={
        "age": 26
    })
    print(f"Status: {response.status_code}")
    print(f"Response: {response.json()}\n")

    # 4. GET - 목록 조회
    print("4. GET /users (전체 목록)")
    response = requests.get(f"{BASE_URL}/users")
    print(f"Status: {response.status_code}")
    print(f"Response: {response.json()}\n")

    # 5. DELETE - 사용자 삭제
    print(f"5. DELETE /users/{user_id} (사용자 삭제)")
    response = requests.delete(f"{BASE_URL}/users/{user_id}")
    print(f"Status: {response.status_code}\n")

if __name__ == "__main__":
    test_api()
```

### 8.3. 실행 방법

```bash
# 1. FastAPI 설치
pip install fastapi uvicorn[standard] pydantic[email]

# 2. 서버 실행
uvicorn main:app --reload

# 3. 브라우저에서 문서 확인
http://localhost:8000/docs  # Swagger UI
http://localhost:8000/redoc # ReDoc

# 4. 테스트 실행 (다른 터미널)
python test_api.py
```

---

## 다음 단계

FastAPI에서 API를 만드는 방법을 이해했다면, 다음 단계에서는 **디자인 패턴**을 적용하여 코드를 구조화하는 방법을 배워보겠습니다.

**다음 문서**: [1.3.05. FastAPI 디자인패턴](./1.3.05.FastAPI%20디자인패턴.md)

### 다음에 배울 내용
- Router 패턴
- Service 패턴
- Repository 패턴
- 각 패턴의 장단점
- 실전 예시

---

**참고 자료**:
- FastAPI 공식 문서: https://fastapi.tiangolo.com/
- HTTP 메서드: https://developer.mozilla.org/ko/docs/Web/HTTP/Methods
- REST API 설계: https://restfulapi.net/
- Pydantic 문서: https://docs.pydantic.dev/
