# 1.3.02. SQLAlchemy 모델 만들기

> **작성자**: Bern
> **작성일**: 2025-10-26
> **카테고리**: 데이터베이스

---

## 목차
1. [SQLAlchemy에서 Model의 개념](#1-sqlalchemy에서-model의-개념)
2. [Model 구성 요소](#2-model-구성-요소)
3. [테이블 생성과 조작](#3-테이블-생성과-조작)
4. [관계 설정](#4-관계-설정)
5. [실습 코드](#5-실습-코드)

---

## 1. SQLAlchemy에서 Model의 개념

### 1.1. Model이란?

**Model(모델)**은 데이터베이스 테이블을 Python 클래스로 표현한 것입니다. ORM의 핵심 개념으로, 테이블의 구조와 동작을 정의합니다.

```
[Database Table]          [Python Model Class]
┌─────────────────┐      ┌──────────────────────┐
│ users           │  ←→  │ class User(Base):    │
├─────────────────┤      │   id = Column(...)   │
│ id   INTEGER    │      │   name = Column(...) │
│ name TEXT       │      │   email = Column(...)│
│ email TEXT      │      └──────────────────────┘
└─────────────────┘
```

### 1.2. Model의 역할

| 역할 | 설명 |
|-----|------|
| **스키마 정의** | 테이블의 컬럼, 타입, 제약조건 정의 |
| **데이터 매핑** | DB 레코드 ↔ Python 객체 자동 변환 |
| **관계 표현** | 테이블 간 관계(1:N, N:M) 정의 |
| **유효성 검증** | 데이터 타입, 제약조건 자동 검증 |
| **쿼리 인터페이스** | 객체를 통한 직관적인 쿼리 작성 |

### 1.3. Declarative Base

모든 모델은 **Base** 클래스를 상속받아 작성합니다.

```python
from sqlalchemy.orm import declarative_base

# Base 클래스 생성 (프로젝트당 1회)
Base = declarative_base()

# 모델 정의
class User(Base):
    __tablename__ = 'users'
    # ... 컬럼 정의
```

**Base의 역할**:
- 메타데이터 관리
- 테이블 스키마 추적
- 모든 모델의 공통 기능 제공

---

## 2. Model 구성 요소

### 2.1. 기본 구조

```python
from sqlalchemy import Column, Integer, String, Boolean, DateTime
from sqlalchemy.orm import declarative_base
from datetime import datetime

Base = declarative_base()

class User(Base):
    # 1. 테이블 이름 (필수)
    __tablename__ = 'users'

    # 2. 컬럼 정의
    id = Column(Integer, primary_key=True)
    username = Column(String(50), unique=True, nullable=False)
    email = Column(String(100), unique=True, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.now)

    # 3. 메서드 (선택)
    def __repr__(self):
        return f"<User(id={self.id}, username='{self.username}')>"
```

### 2.2. 컬럼 타입

#### 주요 데이터 타입

| SQLAlchemy 타입 | Python 타입 | SQL 타입 | 설명 |
|----------------|------------|---------|------|
| `Integer` | `int` | INTEGER | 정수 |
| `String(n)` | `str` | VARCHAR(n) | 가변 길이 문자열 |
| `Text` | `str` | TEXT | 긴 텍스트 |
| `Boolean` | `bool` | BOOLEAN | 참/거짓 |
| `Float` | `float` | FLOAT | 실수 |
| `DateTime` | `datetime` | DATETIME | 날짜/시간 |
| `Date` | `date` | DATE | 날짜만 |
| `JSON` | `dict` | JSON | JSON 데이터 |

#### 타입 사용 예시

```python
from sqlalchemy import Column, Integer, String, Text, Boolean, Float, DateTime, Date, JSON
from datetime import datetime, date

class Product(Base):
    __tablename__ = 'products'

    id = Column(Integer, primary_key=True)
    name = Column(String(100))              # 짧은 문자열
    description = Column(Text)              # 긴 텍스트
    price = Column(Float)                   # 가격 (실수)
    in_stock = Column(Boolean, default=True)  # 재고 여부
    created_at = Column(DateTime, default=datetime.now)  # 생성 일시
    release_date = Column(Date)             # 출시일
    metadata_json = Column(JSON)            # JSON 데이터
```

### 2.3. 컬럼 제약조건

#### 주요 제약조건

| 제약조건 | 설명 | 예시 |
|---------|------|------|
| `primary_key` | 기본 키 | `Column(Integer, primary_key=True)` |
| `unique` | 고유 값 | `Column(String, unique=True)` |
| `nullable` | NULL 허용 여부 | `Column(String, nullable=False)` |
| `default` | 기본값 | `Column(Boolean, default=True)` |
| `index` | 인덱스 생성 | `Column(String, index=True)` |
| `autoincrement` | 자동 증가 | `Column(Integer, autoincrement=True)` |

#### 제약조건 조합 예시

```python
class User(Base):
    __tablename__ = 'users'

    # 1. 기본 키 (자동 증가)
    id = Column(Integer, primary_key=True, autoincrement=True)

    # 2. 고유 + NULL 불가
    username = Column(String(50), unique=True, nullable=False)

    # 3. 고유 + NULL 불가 + 인덱스
    email = Column(String(100), unique=True, nullable=False, index=True)

    # 4. 기본값
    is_active = Column(Boolean, default=True, nullable=False)

    # 5. 자동 생성 시간
    created_at = Column(DateTime, default=datetime.now, nullable=False)

    # 6. NULL 허용
    phone = Column(String(20), nullable=True)
```

### 2.4. 복합 제약조건

```python
from sqlalchemy import UniqueConstraint, CheckConstraint, Index

class Article(Base):
    __tablename__ = 'articles'

    id = Column(Integer, primary_key=True)
    title = Column(String(200), nullable=False)
    author = Column(String(100), nullable=False)
    view_count = Column(Integer, default=0)
    rating = Column(Float)

    # 복합 유니크 제약 (제목 + 작성자 조합이 유니크)
    __table_args__ = (
        UniqueConstraint('title', 'author', name='uq_title_author'),
        CheckConstraint('rating >= 0 AND rating <= 5', name='ck_rating_range'),
        Index('idx_author_title', 'author', 'title'),  # 복합 인덱스
    )
```

### 2.5. 컬럼 옵션 정리

```python
class ExampleModel(Base):
    __tablename__ = 'examples'

    # 모든 옵션 예시
    id = Column(
        Integer,                    # 타입
        primary_key=True,           # 기본 키
        autoincrement=True,         # 자동 증가
        nullable=False,             # NOT NULL
        unique=False,               # 고유 여부
        index=False,                # 인덱스 생성
        default=None,               # 기본값
        server_default=None,        # DB 레벨 기본값
        comment='ID 컬럼'           # 주석 (일부 DB만 지원)
    )
```

---

## 3. 테이블 생성과 조작

### 3.1. 테이블 생성

#### 전체 테이블 생성

```python
from sqlalchemy import create_engine
from sqlalchemy.orm import declarative_base

Base = declarative_base()

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String(50))

class Post(Base):
    __tablename__ = 'posts'
    id = Column(Integer, primary_key=True)
    title = Column(String(200))

# Engine 생성
engine = create_engine('sqlite:///app.db')

# 모든 테이블 생성
Base.metadata.create_all(engine)
```

**생성되는 SQL**:
```sql
CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    name VARCHAR(50)
);

CREATE TABLE posts (
    id INTEGER PRIMARY KEY,
    title VARCHAR(200)
);
```

#### 특정 테이블만 생성

```python
# User 테이블만 생성
User.__table__.create(engine)

# Post 테이블만 생성
Post.__table__.create(engine)
```

### 3.2. 테이블 삭제

```python
# 모든 테이블 삭제
Base.metadata.drop_all(engine)

# 특정 테이블만 삭제
User.__table__.drop(engine)
```

### 3.3. 테이블 존재 여부 확인

```python
from sqlalchemy import inspect

# Inspector 생성
inspector = inspect(engine)

# 모든 테이블 목록
table_names = inspector.get_table_names()
print(f"테이블 목록: {table_names}")

# 특정 테이블 존재 확인
if 'users' in table_names:
    print("users 테이블이 존재합니다")

# 테이블 정보 확인
columns = inspector.get_columns('users')
for column in columns:
    print(f"컬럼: {column['name']}, 타입: {column['type']}")
```

### 3.4. 테이블 재생성

```python
# 안전한 재생성 (존재하면 무시)
Base.metadata.create_all(engine, checkfirst=True)

# 강제 재생성 (기존 데이터 삭제됨!)
Base.metadata.drop_all(engine)
Base.metadata.create_all(engine)
```

---

## 4. 관계 설정

### 4.1. One-to-Many (1:N) 관계

#### 예시: 사용자 1명 - 게시글 여러 개

```python
from sqlalchemy import ForeignKey
from sqlalchemy.orm import relationship

class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    username = Column(String(50), nullable=False)

    # 관계 정의: User → Posts
    posts = relationship('Post', back_populates='author')

class Post(Base):
    __tablename__ = 'posts'

    id = Column(Integer, primary_key=True)
    title = Column(String(200), nullable=False)
    content = Column(Text)

    # 외래 키
    user_id = Column(Integer, ForeignKey('users.id'), nullable=False)

    # 관계 정의: Post → User
    author = relationship('User', back_populates='posts')
```

**사용 예시**:
```python
# 사용자 생성
user = User(username='홍길동')

# 게시글 생성 및 연결
post1 = Post(title='첫 번째 글', content='내용...', author=user)
post2 = Post(title='두 번째 글', content='내용...', author=user)

# 저장
session.add(user)
session.commit()

# 조회
user = session.query(User).first()
print(f"{user.username}의 게시글: {len(user.posts)}개")
for post in user.posts:
    print(f"  - {post.title}")
```

### 4.2. Many-to-Many (N:M) 관계

#### 예시: 학생 - 수업 (다대다)

```python
from sqlalchemy import Table

# 연결 테이블 (Association Table)
student_course = Table(
    'student_course',
    Base.metadata,
    Column('student_id', Integer, ForeignKey('students.id'), primary_key=True),
    Column('course_id', Integer, ForeignKey('courses.id'), primary_key=True)
)

class Student(Base):
    __tablename__ = 'students'

    id = Column(Integer, primary_key=True)
    name = Column(String(50), nullable=False)

    # N:M 관계
    courses = relationship('Course', secondary=student_course, back_populates='students')

class Course(Base):
    __tablename__ = 'courses'

    id = Column(Integer, primary_key=True)
    name = Column(String(100), nullable=False)

    # N:M 관계
    students = relationship('Student', secondary=student_course, back_populates='courses')
```

**사용 예시**:
```python
# 학생 생성
student1 = Student(name='홍길동')
student2 = Student(name='김철수')

# 수업 생성
math = Course(name='수학')
science = Course(name='과학')

# 관계 설정
student1.courses.extend([math, science])
student2.courses.append(math)

session.add_all([student1, student2])
session.commit()

# 조회
student = session.query(Student).filter(Student.name == '홍길동').first()
print(f"{student.name}이 듣는 수업:")
for course in student.courses:
    print(f"  - {course.name}")
```

### 4.3. One-to-One (1:1) 관계

#### 예시: 사용자 - 프로필

```python
class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    username = Column(String(50), nullable=False)

    # 1:1 관계 (uselist=False)
    profile = relationship('Profile', back_populates='user', uselist=False)

class Profile(Base):
    __tablename__ = 'profiles'

    id = Column(Integer, primary_key=True)
    bio = Column(Text)
    avatar_url = Column(String(200))

    # 외래 키 (unique=True로 1:1 보장)
    user_id = Column(Integer, ForeignKey('users.id'), unique=True, nullable=False)

    # 관계 정의
    user = relationship('User', back_populates='profile')
```

**사용 예시**:
```python
# 사용자 + 프로필 생성
user = User(username='홍길동')
profile = Profile(bio='안녕하세요', avatar_url='https://...', user=user)

session.add(user)
session.commit()

# 조회
user = session.query(User).first()
print(f"{user.username}의 프로필: {user.profile.bio}")
```

### 4.4. 관계 옵션

| 옵션 | 설명 | 예시 |
|-----|------|------|
| `back_populates` | 양방향 관계 설정 | `back_populates='posts'` |
| `uselist` | 리스트 여부 (1:1에서 False) | `uselist=False` |
| `cascade` | 삭제/수정 전파 | `cascade='all, delete-orphan'` |
| `lazy` | 로딩 방식 | `lazy='select'` (기본값) |
| `foreign_keys` | 외래 키 명시 | `foreign_keys=[user_id]` |

#### Cascade 옵션

```python
class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)

    # 사용자 삭제 시 게시글도 함께 삭제
    posts = relationship(
        'Post',
        back_populates='author',
        cascade='all, delete-orphan'
    )
```

**Cascade 종류**:
- `all`: 모든 작업 전파
- `delete`: 삭제 전파
- `delete-orphan`: 부모 없는 자식 삭제
- `save-update`: 저장/수정 전파
- `merge`: 병합 전파

---

## 5. 실습 코드

### 5.1. 기본 모델 생성

```python
# 01_basic_model.py
import sys, io
if sys.platform == 'win32':
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')

from sqlalchemy import create_engine, Column, Integer, String, Boolean, DateTime
from sqlalchemy.orm import declarative_base, Session
from datetime import datetime

Base = declarative_base()

class User(Base):
    """사용자 모델"""
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True, autoincrement=True)
    username = Column(String(50), unique=True, nullable=False)
    email = Column(String(100), unique=True, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.now)

    def __repr__(self):
        return f"<User(id={self.id}, username='{self.username}')>"

def test_basic_model():
    """기본 모델 테스트"""

    # Engine 생성
    engine = create_engine('sqlite:///users.db', echo=False)

    # 테이블 생성
    Base.metadata.create_all(engine)
    print("=== 테이블 생성 완료 ===\n")

    # 데이터 생성
    with Session(engine) as session:
        users = [
            User(username='hong', email='hong@test.com'),
            User(username='kim', email='kim@test.com'),
            User(username='lee', email='lee@test.com', is_active=False)
        ]
        session.add_all(users)
        session.commit()
        print(f"=== {len(users)}명의 사용자 추가됨 ===\n")

    # 데이터 조회
    with Session(engine) as session:
        print("=== 전체 사용자 목록 ===")
        all_users = session.query(User).all()
        for user in all_users:
            status = "활성" if user.is_active else "비활성"
            print(f"  {user.username} ({user.email}) - {status}")

        print("\n=== 활성 사용자만 조회 ===")
        active_users = session.query(User).filter(User.is_active == True).all()
        for user in active_users:
            print(f"  {user.username}")

if __name__ == "__main__":
    test_basic_model()
```

### 5.2. 1:N 관계 모델

```python
# 02_one_to_many.py
import sys, io
if sys.platform == 'win32':
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')

from sqlalchemy import create_engine, Column, Integer, String, Text, ForeignKey, DateTime
from sqlalchemy.orm import declarative_base, relationship, Session
from datetime import datetime

Base = declarative_base()

class Author(Base):
    """작성자 모델"""
    __tablename__ = 'authors'

    id = Column(Integer, primary_key=True)
    name = Column(String(50), nullable=False)

    # 1:N 관계
    articles = relationship('Article', back_populates='author', cascade='all, delete-orphan')

    def __repr__(self):
        return f"<Author(name='{self.name}')>"

class Article(Base):
    """게시글 모델"""
    __tablename__ = 'articles'

    id = Column(Integer, primary_key=True)
    title = Column(String(200), nullable=False)
    content = Column(Text)
    created_at = Column(DateTime, default=datetime.now)

    # 외래 키
    author_id = Column(Integer, ForeignKey('authors.id'), nullable=False)

    # 관계
    author = relationship('Author', back_populates='articles')

    def __repr__(self):
        return f"<Article(title='{self.title}')>"

def test_one_to_many():
    """1:N 관계 테스트"""

    engine = create_engine('sqlite:///blog.db', echo=False)
    Base.metadata.create_all(engine)

    with Session(engine) as session:
        # 작성자 생성
        author1 = Author(name='홍길동')
        author2 = Author(name='김철수')

        # 게시글 생성 및 연결
        article1 = Article(title='첫 번째 글', content='내용...', author=author1)
        article2 = Article(title='두 번째 글', content='내용...', author=author1)
        article3 = Article(title='김철수의 글', content='내용...', author=author2)

        session.add_all([author1, author2])
        session.commit()

        print("=== 작성자별 게시글 ===")
        authors = session.query(Author).all()
        for author in authors:
            print(f"\n{author.name}의 게시글 ({len(author.articles)}개):")
            for article in author.articles:
                print(f"  - {article.title}")

        print("\n=== 게시글의 작성자 ===")
        articles = session.query(Article).all()
        for article in articles:
            print(f"{article.title} → 작성자: {article.author.name}")

if __name__ == "__main__":
    test_one_to_many()
```

### 5.3. N:M 관계 모델

```python
# 03_many_to_many.py
import sys, io
if sys.platform == 'win32':
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')

from sqlalchemy import create_engine, Column, Integer, String, Table, ForeignKey
from sqlalchemy.orm import declarative_base, relationship, Session

Base = declarative_base()

# 연결 테이블
tag_article = Table(
    'tag_article',
    Base.metadata,
    Column('tag_id', Integer, ForeignKey('tags.id'), primary_key=True),
    Column('article_id', Integer, ForeignKey('articles.id'), primary_key=True)
)

class Tag(Base):
    """태그 모델"""
    __tablename__ = 'tags'

    id = Column(Integer, primary_key=True)
    name = Column(String(50), unique=True, nullable=False)

    # N:M 관계
    articles = relationship('Article', secondary=tag_article, back_populates='tags')

    def __repr__(self):
        return f"<Tag(name='{self.name}')>"

class Article(Base):
    """게시글 모델"""
    __tablename__ = 'articles'

    id = Column(Integer, primary_key=True)
    title = Column(String(200), nullable=False)

    # N:M 관계
    tags = relationship('Tag', secondary=tag_article, back_populates='articles')

    def __repr__(self):
        return f"<Article(title='{self.title}')>"

def test_many_to_many():
    """N:M 관계 테스트"""

    engine = create_engine('sqlite:///tags.db', echo=False)
    Base.metadata.create_all(engine)

    with Session(engine) as session:
        # 태그 생성
        python = Tag(name='Python')
        web = Tag(name='Web')
        database = Tag(name='Database')

        # 게시글 생성
        article1 = Article(title='Python 웹 개발')
        article2 = Article(title='SQLAlchemy 튜토리얼')
        article3 = Article(title='FastAPI 가이드')

        # 관계 설정
        article1.tags.extend([python, web])
        article2.tags.extend([python, database])
        article3.tags.extend([python, web])

        session.add_all([article1, article2, article3])
        session.commit()

        print("=== 게시글별 태그 ===")
        articles = session.query(Article).all()
        for article in articles:
            tag_names = [tag.name for tag in article.tags]
            print(f"{article.title}: {', '.join(tag_names)}")

        print("\n=== 태그별 게시글 ===")
        tags = session.query(Tag).all()
        for tag in tags:
            print(f"\n[{tag.name}] 태그가 있는 게시글 ({len(tag.articles)}개):")
            for article in tag.articles:
                print(f"  - {article.title}")

if __name__ == "__main__":
    test_many_to_many()
```

### 5.4. 실행 방법

```bash
# 1. 기본 모델
python 01_basic_model.py

# 2. 1:N 관계
python 02_one_to_many.py

# 3. N:M 관계
python 03_many_to_many.py
```

### 5.5. 예상 출력

#### 01_basic_model.py
```
=== 테이블 생성 완료 ===

=== 3명의 사용자 추가됨 ===

=== 전체 사용자 목록 ===
  hong (hong@test.com) - 활성
  kim (kim@test.com) - 활성
  lee (lee@test.com) - 비활성

=== 활성 사용자만 조회 ===
  hong
  kim
```

#### 02_one_to_many.py
```
=== 작성자별 게시글 ===

홍길동의 게시글 (2개):
  - 첫 번째 글
  - 두 번째 글

김철수의 게시글 (1개):
  - 김철수의 글

=== 게시글의 작성자 ===
첫 번째 글 → 작성자: 홍길동
두 번째 글 → 작성자: 홍길동
김철수의 글 → 작성자: 김철수
```

#### 03_many_to_many.py
```
=== 게시글별 태그 ===
Python 웹 개발: Python, Web
SQLAlchemy 튜토리얼: Python, Database
FastAPI 가이드: Python, Web

=== 태그별 게시글 ===

[Python] 태그가 있는 게시글 (3개):
  - Python 웹 개발
  - SQLAlchemy 튜토리얼
  - FastAPI 가이드

[Web] 태그가 있는 게시글 (2개):
  - Python 웹 개발
  - FastAPI 가이드

[Database] 태그가 있는 게시글 (1개):
  - SQLAlchemy 튜토리얼
```

---

## 다음 단계

SQLAlchemy 모델의 개념과 관계 설정 방법을 이해했다면, 다음 단계에서는 **SQLAlchemy의 핵심 기능**인 CRUD 작업과 ORM/Core 방식의 차이를 배워보겠습니다.

**다음 문서**: [1.3.03. SQLAlchemy 기능](./1.3.03.SQLAlchemy%20기능.md)

### 다음에 배울 내용
- SELECT (조회)
- INSERT (삽입)
- UPDATE (수정)
- DELETE (삭제)
- ORM 방식 vs Core 방식 비교
- 각 방식의 장단점

---

**참고 자료**:
- SQLAlchemy ORM 관계: https://docs.sqlalchemy.org/en/20/orm/relationships.html
- Declarative Mapping: https://docs.sqlalchemy.org/en/20/orm/mapping_styles.html#declarative-mapping
- Column and Data Types: https://docs.sqlalchemy.org/en/20/core/types.html
