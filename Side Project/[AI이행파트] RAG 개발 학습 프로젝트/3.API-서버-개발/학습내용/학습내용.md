# 3단계: API 서버 개발 - 학습 내용

> **학습 기간**: 2025년 10월
> **소요 시간**: 12시간
> **학습 목표**: SQLAlchemy와 FastAPI를 활용한 RESTful API 서버 개발

---

## 📚 학습 주제

1. SQLAlchemy (ORM)
2. FastAPI (REST API)
3. 디자인 패턴 (3계층 아키텍처)
4. Logging (로깅 시스템)

---

## 1. SQLAlchemy (ORM)

### 학습 내용

#### 1.1 ORM이란?

**ORM (Object-Relational Mapping)**:
- 객체와 관계형 데이터베이스를 매핑
- SQL을 직접 작성하지 않고 Python 코드로 DB 조작

**장점**:
| 장점 | 설명 |
|-----|------|
| 생산성 | SQL 몰라도 DB 조작 가능 |
| 유지보수성 | 객체 지향적 코드 |
| DB 독립성 | MySQL ↔ PostgreSQL 쉽게 변경 |
| 타입 안전성 | IDE 자동완성 지원 |

**단점**:
| 단점 | 설명 |
|-----|------|
| 성능 오버헤드 | 복잡한 쿼리는 Raw SQL보다 느림 |
| 학습 곡선 | ORM 자체를 학습해야 함 |

#### 1.2 모델 정의

**기본 구조**:
```python
from sqlalchemy import Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    name = Column(String(50))
    email = Column(String(100), unique=True)
```

**컬럼 타입**:
| SQLAlchemy | Python | SQL |
|-----------|--------|-----|
| `Integer` | `int` | INTEGER |
| `String(n)` | `str` | VARCHAR(n) |
| `Text` | `str` | TEXT |
| `Boolean` | `bool` | BOOLEAN |
| `DateTime` | `datetime` | DATETIME |
| `JSON` | `dict` | JSON |

**제약조건**:
- `primary_key=True`: 기본 키
- `unique=True`: 고유 값
- `nullable=False`: NULL 불가
- `default=값`: 기본값

#### 1.3 CRUD 작업

**CREATE (생성)**:
```python
user = User(name='홍길동', email='hong@test.com')
session.add(user)
session.commit()
```

**READ (조회)**:
```python
# 전체 조회
users = session.query(User).all()

# 조건 조회
user = session.query(User).filter(User.id == 1).first()

# 여러 조건
users = session.query(User).filter(
    User.age >= 20,
    User.is_active == True
).all()
```

**UPDATE (수정)**:
```python
user = session.query(User).filter(User.id == 1).first()
user.email = 'new@test.com'
session.commit()
```

**DELETE (삭제)**:
```python
user = session.query(User).filter(User.id == 1).first()
session.delete(user)
session.commit()
```

#### 1.4 관계 설정

**1:N (One-to-Many)**:
```python
class Author(Base):
    __tablename__ = 'authors'
    id = Column(Integer, primary_key=True)
    name = Column(String(50))

    # 관계 정의
    posts = relationship('Post', back_populates='author')

class Post(Base):
    __tablename__ = 'posts'
    id = Column(Integer, primary_key=True)
    title = Column(String(200))
    author_id = Column(Integer, ForeignKey('authors.id'))

    # 관계 정의
    author = relationship('Author', back_populates='posts')
```

**N:M (Many-to-Many)**:
```python
# 연결 테이블
student_course = Table('student_course', Base.metadata,
    Column('student_id', Integer, ForeignKey('students.id')),
    Column('course_id', Integer, ForeignKey('courses.id'))
)

class Student(Base):
    __tablename__ = 'students'
    id = Column(Integer, primary_key=True)
    courses = relationship('Course', secondary=student_course)
```

### 학습 포인트
- ✅ ORM의 개념과 필요성
- ✅ 모델 정의 및 CRUD 작업
- ✅ 1:N, N:M 관계 설정

---

## 2. FastAPI (REST API)

### 학습 내용

#### 2.1 HTTP 메서드

| 메서드 | 의미 | CRUD | 용도 |
|-------|------|------|------|
| **GET** | 조회 | Read | 리소스 조회 |
| **POST** | 생성 | Create | 리소스 생성 |
| **PUT** | 전체 수정 | Update | 리소스 전체 교체 |
| **PATCH** | 부분 수정 | Update | 리소스 일부 수정 |
| **DELETE** | 삭제 | Delete | 리소스 삭제 |

#### 2.2 RESTful API 설계

**URL 규칙**:
```
GET    /users        # 사용자 목록 조회
GET    /users/1      # ID가 1인 사용자 조회
POST   /users        # 새 사용자 생성
PUT    /users/1      # ID가 1인 사용자 전체 수정
PATCH  /users/1      # ID가 1인 사용자 일부 수정
DELETE /users/1      # ID가 1인 사용자 삭제
```

#### 2.3 FastAPI 기본 사용

**설치**:
```bash
pip install fastapi uvicorn
```

**기본 앱**:
```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def root():
    return {"message": "Hello World"}

@app.get("/users/{user_id}")
def get_user(user_id: int):
    return {"user_id": user_id}
```

**실행**:
```bash
uvicorn main:app --reload
```

#### 2.4 Request/Response 모델

**Pydantic 모델**:
```python
from pydantic import BaseModel

class UserCreate(BaseModel):
    name: str
    email: str

class UserResponse(BaseModel):
    id: int
    name: str
    email: str

@app.post("/users", response_model=UserResponse)
def create_user(user: UserCreate):
    return {"id": 1, "name": user.name, "email": user.email}
```

#### 2.5 HTTP 데이터 전송

| 방법 | 위치 | Content-Type | 용도 |
|-----|------|-------------|------|
| **Body** | Request Body | `application/json` | JSON 데이터 |
| **Query** | URL Parameter | - | 필터, 페이지네이션 |
| **Path** | URL Path | - | 리소스 ID |
| **Form** | Request Body | `application/x-www-form-urlencoded` | HTML 폼 |
| **File** | Request Body | `multipart/form-data` | 파일 업로드 |

**사용 예시**:
```python
from fastapi import Query, Body, File

@app.get("/items")
def get_items(skip: int = Query(0), limit: int = Query(10)):
    return {"skip": skip, "limit": limit}

@app.post("/upload")
async def upload_file(file: UploadFile = File(...)):
    return {"filename": file.filename}
```

#### 2.6 상태 코드

| 코드 | 의미 | 사용 예시 |
|-----|------|----------|
| **200** | OK | 성공적인 GET, PUT |
| **201** | Created | 리소스 생성 (POST) |
| **204** | No Content | 삭제 성공 (DELETE) |
| **400** | Bad Request | 잘못된 요청 |
| **404** | Not Found | 리소스 없음 |
| **500** | Server Error | 서버 오류 |

### 학습 포인트
- ✅ RESTful API 설계 원칙
- ✅ HTTP 메서드별 용도
- ✅ Request/Response 모델 정의

---

## 3. 디자인 패턴 (3계층 아키텍처)

### 학습 내용

#### 3.1 3계층 구조

```
┌─────────────────────────────────────┐
│   Router (Presentation Layer)      │  ← HTTP 요청/응답
├─────────────────────────────────────┤
│   Service (Business Logic Layer)   │  ← 비즈니스 로직
├─────────────────────────────────────┤
│   Repository (Data Access Layer)   │  ← DB 접근
└─────────────────────────────────────┘
```

#### 3.2 각 계층의 역할

| 계층 | 역할 | 책임 |
|-----|------|------|
| **Router** | HTTP 처리 | 요청 파싱, 응답 형식화 |
| **Service** | 비즈니스 로직 | 업무 규칙, 데이터 가공 |
| **Repository** | 데이터 접근 | CRUD, 쿼리 실행 |

#### 3.3 계층별 구현

**Repository (데이터 접근)**:
```python
class UserRepository:
    def __init__(self, db: Session):
        self.db = db

    def find_by_id(self, user_id: int):
        return self.db.query(User).filter(User.id == user_id).first()

    def create(self, user_data: dict):
        user = User(**user_data)
        self.db.add(user)
        self.db.commit()
        return user
```

**Service (비즈니스 로직)**:
```python
class UserService:
    def __init__(self, repository: UserRepository):
        self.repository = repository

    def create_user(self, user: UserCreate):
        # 이메일 중복 체크 (비즈니스 로직)
        if self.repository.find_by_email(user.email):
            raise HTTPException(400, "Email exists")

        # 비밀번호 암호화 (비즈니스 로직)
        hashed_password = hash_password(user.password)

        # Repository 호출
        return self.repository.create({
            **user.dict(),
            "password": hashed_password
        })
```

**Router (HTTP 처리)**:
```python
@app.post("/users", status_code=201)
def create_user(
    user: UserCreate,
    service: UserService = Depends()
):
    """사용자 생성 - Router는 HTTP만 처리"""
    return service.create_user(user)
```

#### 3.4 장단점

**장점**:
- ✅ 관심사 분리 (Separation of Concerns)
- ✅ 테스트 용이성 (Mock 사용)
- ✅ 코드 재사용성
- ✅ 유지보수 편의성

**단점**:
- ❌ 코드량 증가 (보일러플레이트)
- ❌ 작은 프로젝트에는 과할 수 있음

**언제 사용?**:
- API 10개 이상
- 복잡한 비즈니스 로직
- 팀 협업 프로젝트

### 학습 포인트
- ✅ 3계층 아키텍처의 구조
- ✅ 각 계층의 책임 분리
- ✅ 의존성 주입 (Dependency Injection)

---

## 4. Logging (로깅 시스템)

### 학습 내용

#### 4.1 로그의 필요성

| 목적 | 설명 |
|-----|------|
| **디버깅** | 버그 원인 파악 |
| **모니터링** | 애플리케이션 상태 추적 |
| **성능 분석** | 느린 API 찾기 |
| **보안** | 비정상 접근 감지 |
| **감사** | 누가 언제 무엇을 했는지 기록 |

#### 4.2 로그 레벨

| 레벨 | 용도 | 예시 |
|-----|------|------|
| **DEBUG** | 상세한 디버깅 정보 | 변수 값, 함수 호출 |
| **INFO** | 일반 정보 | 서버 시작, 요청 처리 |
| **WARNING** | 경고 메시지 | 더 이상 사용되지 않는 기능 |
| **ERROR** | 에러 발생 | 예외 처리, 실패한 작업 |
| **CRITICAL** | 심각한 오류 | 서버 다운 |

#### 4.3 로깅 설정

**기본 설정**:
```python
import logging

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)

logger = logging.getLogger(__name__)
logger.info("Application started")
```

**출력 예시**:
```
2025-10-26 10:30:15 - __main__ - INFO - Application started
```

#### 4.4 파일 로깅

**로테이션 설정**:
```python
from logging.handlers import RotatingFileHandler

handler = RotatingFileHandler(
    'app.log',
    maxBytes=10*1024*1024,  # 10MB
    backupCount=5  # 최대 5개 파일 보관
)
```

**시간 기반 로테이션**:
```python
from logging.handlers import TimedRotatingFileHandler

handler = TimedRotatingFileHandler(
    'app.log',
    when='midnight',  # 매일 자정
    backupCount=30  # 30일 보관
)
```

#### 4.5 요청/응답 로깅

**미들웨어**:
```python
@app.middleware("http")
async def log_requests(request: Request, call_next):
    start_time = time.time()

    logger.info(f"Request: {request.method} {request.url.path}")

    response = await call_next(request)

    process_time = time.time() - start_time
    logger.info(
        f"Response: {request.method} {request.url.path} "
        f"- Status: {response.status_code} "
        f"- Time: {process_time:.3f}s"
    )

    return response
```

#### 4.6 환경별 로그 레벨

| 환경 | 레벨 | 이유 |
|-----|------|------|
| **개발** | DEBUG | 모든 정보 필요 |
| **스테이징** | INFO | 일반 정보만 |
| **운영** | WARNING | 경고 이상만 |

### 학습 포인트
- ✅ 로그 레벨 이해
- ✅ 파일 로테이션 설정
- ✅ 요청/응답 로깅 미들웨어

---

## 💡 통합 예시: 전체 구조

### 프로젝트 구조
```
project/
├── main.py              # FastAPI 앱
├── models/              # SQLAlchemy 모델
│   └── user_model.py
├── schemas/             # Pydantic 스키마
│   └── user_schema.py
├── routers/             # Router 계층
│   └── user_router.py
├── services/            # Service 계층
│   └── user_service.py
└── repositories/        # Repository 계층
    └── user_repository.py
```

### 데이터 흐름
```
1. Client → POST /users (HTTP 요청)
   ↓
2. Router: create_user() 호출
   ↓
3. Service.create_user()
   - 이메일 중복 체크
   - 비밀번호 암호화
   - Repository.create() 호출
   ↓
4. Repository.create()
   - DB INSERT
   ↓
5. Response: 201 Created + User 정보
```

---

## 📖 참고 자료

### 내부 문서 (R&D 폴더)
- 1.3.01 ~ 1.3.06: SQLAlchemy, FastAPI 상세 가이드

### 외부 문서
- [SQLAlchemy Documentation](https://docs.sqlalchemy.org/)
- [FastAPI Documentation](https://fastapi.tiangolo.com/)
- [Python Logging](https://docs.python.org/3/library/logging.html)

---

**작성일**: 2025년 10월 26일
**학습 완료**: ✅
